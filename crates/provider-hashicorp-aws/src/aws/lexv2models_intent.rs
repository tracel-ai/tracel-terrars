use super::provider::ProviderAws;
use serde::Serialize;
use std::cell::RefCell;
use std::rc::Rc;
use terrars::*;
#[derive(Serialize)]
struct Lexv2modelsIntentData {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    depends_on: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    provider: Option<String>,
    #[serde(skip_serializing_if = "SerdeSkipDefault::is_default")]
    lifecycle: ResourceLifecycle,
    #[serde(skip_serializing_if = "Option::is_none")]
    for_each: Option<String>,
    bot_id: PrimField<String>,
    bot_version: PrimField<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    description: Option<PrimField<String>>,
    locale_id: PrimField<String>,
    name: PrimField<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    parent_intent_signature: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    region: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    closing_setting: Option<Vec<Lexv2modelsIntentClosingSettingEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    confirmation_setting: Option<Vec<Lexv2modelsIntentConfirmationSettingEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    dialog_code_hook: Option<Vec<Lexv2modelsIntentDialogCodeHookEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    fulfillment_code_hook: Option<Vec<Lexv2modelsIntentFulfillmentCodeHookEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    initial_response_setting: Option<Vec<Lexv2modelsIntentInitialResponseSettingEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    input_context: Option<Vec<Lexv2modelsIntentInputContextEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    kendra_configuration: Option<Vec<Lexv2modelsIntentKendraConfigurationEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    output_context: Option<Vec<Lexv2modelsIntentOutputContextEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    sample_utterance: Option<Vec<Lexv2modelsIntentSampleUtteranceEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_priority: Option<Vec<Lexv2modelsIntentSlotPriorityEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    timeouts: Option<Lexv2modelsIntentTimeoutsEl>,
    dynamic: Lexv2modelsIntentDynamic,
}
struct Lexv2modelsIntent_ {
    shared: StackShared,
    tf_id: String,
    data: RefCell<Lexv2modelsIntentData>,
}
#[derive(Clone)]
pub struct Lexv2modelsIntent(Rc<Lexv2modelsIntent_>);
impl Lexv2modelsIntent {
    fn shared(&self) -> &StackShared {
        &self.0.shared
    }
    pub fn depends_on(self, dep: &impl Referable) -> Self {
        self.0.data.borrow_mut().depends_on.push(dep.extract_ref());
        self
    }
    pub fn set_provider(self, provider: &ProviderAws) -> Self {
        self.0.data.borrow_mut().provider = Some(provider.provider_ref());
        self
    }
    pub fn set_create_before_destroy(self, v: bool) -> Self {
        self.0.data.borrow_mut().lifecycle.create_before_destroy = v;
        self
    }
    pub fn set_prevent_destroy(self, v: bool) -> Self {
        self.0.data.borrow_mut().lifecycle.prevent_destroy = v;
        self
    }
    pub fn ignore_changes_to_all(self) -> Self {
        self.0.data.borrow_mut().lifecycle.ignore_changes =
            Some(IgnoreChanges::All(IgnoreChangesAll::All));
        self
    }
    pub fn ignore_changes_to_attr(self, attr: impl ToString) -> Self {
        {
            let mut d = self.0.data.borrow_mut();
            if match &mut d.lifecycle.ignore_changes {
                Some(i) => match i {
                    IgnoreChanges::All(_) => true,
                    IgnoreChanges::Refs(r) => {
                        r.push(attr.to_string());
                        false
                    }
                },
                None => true,
            } {
                d.lifecycle.ignore_changes = Some(IgnoreChanges::Refs(vec![attr.to_string()]));
            }
        }
        self
    }
    pub fn replace_triggered_by_resource(self, r: &impl Resource) -> Self {
        self.0
            .data
            .borrow_mut()
            .lifecycle
            .replace_triggered_by
            .push(r.extract_ref());
        self
    }
    pub fn replace_triggered_by_attr(self, attr: impl ToString) -> Self {
        self.0
            .data
            .borrow_mut()
            .lifecycle
            .replace_triggered_by
            .push(attr.to_string());
        self
    }
    #[doc = "Set the field `description`.\n"]
    pub fn set_description(self, v: impl Into<PrimField<String>>) -> Self {
        self.0.data.borrow_mut().description = Some(v.into());
        self
    }
    #[doc = "Set the field `parent_intent_signature`.\n"]
    pub fn set_parent_intent_signature(self, v: impl Into<PrimField<String>>) -> Self {
        self.0.data.borrow_mut().parent_intent_signature = Some(v.into());
        self
    }
    #[doc = "Set the field `region`.\nRegion where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the [provider configuration](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#aws-configuration-reference)."]
    pub fn set_region(self, v: impl Into<PrimField<String>>) -> Self {
        self.0.data.borrow_mut().region = Some(v.into());
        self
    }
    #[doc = "Set the field `closing_setting`.\n"]
    pub fn set_closing_setting(
        self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentClosingSettingEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.0.data.borrow_mut().closing_setting = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.0.data.borrow_mut().dynamic.closing_setting = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `confirmation_setting`.\n"]
    pub fn set_confirmation_setting(
        self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentConfirmationSettingEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.0.data.borrow_mut().confirmation_setting = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.0.data.borrow_mut().dynamic.confirmation_setting = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `dialog_code_hook`.\n"]
    pub fn set_dialog_code_hook(
        self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentDialogCodeHookEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.0.data.borrow_mut().dialog_code_hook = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.0.data.borrow_mut().dynamic.dialog_code_hook = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `fulfillment_code_hook`.\n"]
    pub fn set_fulfillment_code_hook(
        self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentFulfillmentCodeHookEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.0.data.borrow_mut().fulfillment_code_hook = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.0.data.borrow_mut().dynamic.fulfillment_code_hook = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `initial_response_setting`.\n"]
    pub fn set_initial_response_setting(
        self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentInitialResponseSettingEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.0.data.borrow_mut().initial_response_setting = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.0.data.borrow_mut().dynamic.initial_response_setting = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `input_context`.\n"]
    pub fn set_input_context(
        self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentInputContextEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.0.data.borrow_mut().input_context = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.0.data.borrow_mut().dynamic.input_context = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `kendra_configuration`.\n"]
    pub fn set_kendra_configuration(
        self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentKendraConfigurationEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.0.data.borrow_mut().kendra_configuration = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.0.data.borrow_mut().dynamic.kendra_configuration = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `output_context`.\n"]
    pub fn set_output_context(
        self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentOutputContextEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.0.data.borrow_mut().output_context = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.0.data.borrow_mut().dynamic.output_context = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `sample_utterance`.\n"]
    pub fn set_sample_utterance(
        self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentSampleUtteranceEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.0.data.borrow_mut().sample_utterance = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.0.data.borrow_mut().dynamic.sample_utterance = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `slot_priority`.\n"]
    pub fn set_slot_priority(
        self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentSlotPriorityEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.0.data.borrow_mut().slot_priority = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.0.data.borrow_mut().dynamic.slot_priority = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `timeouts`.\n"]
    pub fn set_timeouts(self, v: impl Into<Lexv2modelsIntentTimeoutsEl>) -> Self {
        self.0.data.borrow_mut().timeouts = Some(v.into());
        self
    }
    #[doc = "Get a reference to the value of field `bot_id` after provisioning.\n"]
    pub fn bot_id(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.bot_id", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `bot_version` after provisioning.\n"]
    pub fn bot_version(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.bot_version", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `creation_date_time` after provisioning.\n"]
    pub fn creation_date_time(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.creation_date_time", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `description` after provisioning.\n"]
    pub fn description(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.description", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `id` after provisioning.\n"]
    pub fn id(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.id", self.extract_ref()))
    }
    #[doc = "Get a reference to the value of field `intent_id` after provisioning.\n"]
    pub fn intent_id(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.intent_id", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `last_updated_date_time` after provisioning.\n"]
    pub fn last_updated_date_time(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.last_updated_date_time", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `locale_id` after provisioning.\n"]
    pub fn locale_id(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.locale_id", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.name", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `parent_intent_signature` after provisioning.\n"]
    pub fn parent_intent_signature(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.parent_intent_signature", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `region` after provisioning.\nRegion where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the [provider configuration](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#aws-configuration-reference)."]
    pub fn region(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.region", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `closing_setting` after provisioning.\n"]
    pub fn closing_setting(&self) -> ListRef<Lexv2modelsIntentClosingSettingElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.closing_setting", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `confirmation_setting` after provisioning.\n"]
    pub fn confirmation_setting(&self) -> ListRef<Lexv2modelsIntentConfirmationSettingElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.confirmation_setting", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_code_hook` after provisioning.\n"]
    pub fn dialog_code_hook(&self) -> ListRef<Lexv2modelsIntentDialogCodeHookElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_code_hook", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `fulfillment_code_hook` after provisioning.\n"]
    pub fn fulfillment_code_hook(&self) -> ListRef<Lexv2modelsIntentFulfillmentCodeHookElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.fulfillment_code_hook", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `initial_response_setting` after provisioning.\n"]
    pub fn initial_response_setting(
        &self,
    ) -> ListRef<Lexv2modelsIntentInitialResponseSettingElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.initial_response_setting", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `input_context` after provisioning.\n"]
    pub fn input_context(&self) -> ListRef<Lexv2modelsIntentInputContextElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.input_context", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `kendra_configuration` after provisioning.\n"]
    pub fn kendra_configuration(&self) -> ListRef<Lexv2modelsIntentKendraConfigurationElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.kendra_configuration", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `output_context` after provisioning.\n"]
    pub fn output_context(&self) -> ListRef<Lexv2modelsIntentOutputContextElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.output_context", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `sample_utterance` after provisioning.\n"]
    pub fn sample_utterance(&self) -> ListRef<Lexv2modelsIntentSampleUtteranceElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.sample_utterance", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `slot_priority` after provisioning.\n"]
    pub fn slot_priority(&self) -> ListRef<Lexv2modelsIntentSlotPriorityElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.slot_priority", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `timeouts` after provisioning.\n"]
    pub fn timeouts(&self) -> Lexv2modelsIntentTimeoutsElRef {
        Lexv2modelsIntentTimeoutsElRef::new(
            self.shared().clone(),
            format!("{}.timeouts", self.extract_ref()),
        )
    }
}
impl Referable for Lexv2modelsIntent {
    fn extract_ref(&self) -> String {
        format!(
            "{}.{}",
            self.0.extract_resource_type(),
            self.0.extract_tf_id()
        )
    }
}
impl Resource for Lexv2modelsIntent {}
impl ToListMappable for Lexv2modelsIntent {
    type O = ListRef<Lexv2modelsIntentRef>;
    fn do_map(self, base: String) -> Self::O {
        self.0.data.borrow_mut().for_each = Some(format!("${{{}}}", base));
        ListRef::new(self.0.shared.clone(), self.extract_ref())
    }
}
impl Resource_ for Lexv2modelsIntent_ {
    fn extract_resource_type(&self) -> String {
        "aws_lexv2models_intent".into()
    }
    fn extract_tf_id(&self) -> String {
        self.tf_id.clone()
    }
    fn extract_value(&self) -> serde_json::Value {
        serde_json::to_value(&self.data).unwrap()
    }
}
pub struct BuildLexv2modelsIntent {
    pub tf_id: String,
    #[doc = ""]
    pub bot_id: PrimField<String>,
    #[doc = ""]
    pub bot_version: PrimField<String>,
    #[doc = ""]
    pub locale_id: PrimField<String>,
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntent {
    pub fn build(self, stack: &mut Stack) -> Lexv2modelsIntent {
        let out = Lexv2modelsIntent(Rc::new(Lexv2modelsIntent_ {
            shared: stack.shared.clone(),
            tf_id: self.tf_id,
            data: RefCell::new(Lexv2modelsIntentData {
                depends_on: core::default::Default::default(),
                provider: None,
                lifecycle: core::default::Default::default(),
                for_each: None,
                bot_id: self.bot_id,
                bot_version: self.bot_version,
                description: core::default::Default::default(),
                locale_id: self.locale_id,
                name: self.name,
                parent_intent_signature: core::default::Default::default(),
                region: core::default::Default::default(),
                closing_setting: core::default::Default::default(),
                confirmation_setting: core::default::Default::default(),
                dialog_code_hook: core::default::Default::default(),
                fulfillment_code_hook: core::default::Default::default(),
                initial_response_setting: core::default::Default::default(),
                input_context: core::default::Default::default(),
                kendra_configuration: core::default::Default::default(),
                output_context: core::default::Default::default(),
                sample_utterance: core::default::Default::default(),
                slot_priority: core::default::Default::default(),
                timeouts: core::default::Default::default(),
                dynamic: Default::default(),
            }),
        }));
        stack.add_resource(out.0.clone());
        out
    }
}
pub struct Lexv2modelsIntentRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentRef {
    fn new(shared: StackShared, base: String) -> Self {
        Self { shared, base }
    }
}
impl Lexv2modelsIntentRef {
    fn extract_ref(&self) -> String {
        self.base.clone()
    }
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `bot_id` after provisioning.\n"]
    pub fn bot_id(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.bot_id", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `bot_version` after provisioning.\n"]
    pub fn bot_version(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.bot_version", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `creation_date_time` after provisioning.\n"]
    pub fn creation_date_time(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.creation_date_time", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `description` after provisioning.\n"]
    pub fn description(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.description", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `id` after provisioning.\n"]
    pub fn id(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.id", self.extract_ref()))
    }
    #[doc = "Get a reference to the value of field `intent_id` after provisioning.\n"]
    pub fn intent_id(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.intent_id", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `last_updated_date_time` after provisioning.\n"]
    pub fn last_updated_date_time(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.last_updated_date_time", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `locale_id` after provisioning.\n"]
    pub fn locale_id(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.locale_id", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.name", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `parent_intent_signature` after provisioning.\n"]
    pub fn parent_intent_signature(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.parent_intent_signature", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `region` after provisioning.\nRegion where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the [provider configuration](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#aws-configuration-reference)."]
    pub fn region(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.region", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `closing_setting` after provisioning.\n"]
    pub fn closing_setting(&self) -> ListRef<Lexv2modelsIntentClosingSettingElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.closing_setting", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `confirmation_setting` after provisioning.\n"]
    pub fn confirmation_setting(&self) -> ListRef<Lexv2modelsIntentConfirmationSettingElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.confirmation_setting", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_code_hook` after provisioning.\n"]
    pub fn dialog_code_hook(&self) -> ListRef<Lexv2modelsIntentDialogCodeHookElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_code_hook", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `fulfillment_code_hook` after provisioning.\n"]
    pub fn fulfillment_code_hook(&self) -> ListRef<Lexv2modelsIntentFulfillmentCodeHookElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.fulfillment_code_hook", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `initial_response_setting` after provisioning.\n"]
    pub fn initial_response_setting(
        &self,
    ) -> ListRef<Lexv2modelsIntentInitialResponseSettingElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.initial_response_setting", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `input_context` after provisioning.\n"]
    pub fn input_context(&self) -> ListRef<Lexv2modelsIntentInputContextElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.input_context", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `kendra_configuration` after provisioning.\n"]
    pub fn kendra_configuration(&self) -> ListRef<Lexv2modelsIntentKendraConfigurationElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.kendra_configuration", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `output_context` after provisioning.\n"]
    pub fn output_context(&self) -> ListRef<Lexv2modelsIntentOutputContextElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.output_context", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `sample_utterance` after provisioning.\n"]
    pub fn sample_utterance(&self) -> ListRef<Lexv2modelsIntentSampleUtteranceElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.sample_utterance", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `slot_priority` after provisioning.\n"]
    pub fn slot_priority(&self) -> ListRef<Lexv2modelsIntentSlotPriorityElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.slot_priority", self.extract_ref()),
        )
    }
    #[doc = "Get a reference to the value of field `timeouts` after provisioning.\n"]
    pub fn timeouts(&self) -> Lexv2modelsIntentTimeoutsElRef {
        Lexv2modelsIntentTimeoutsElRef::new(
            self.shared().clone(),
            format!("{}.timeouts", self.extract_ref()),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadEl {}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadEl
    {
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadEl {
            value: self.value,
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadElRef
    {
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , }
    }
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]
    pub fn value(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardEl {
    #[doc = "Set the field `image_url`.\n"]
    pub fn set_image_url(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.image_url = Some(v.into());
        self
    }
    #[doc = "Set the field `subtitle`.\n"]
    pub fn set_subtitle(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.subtitle = Some(v.into());
        self
    }
    #[doc = "Set the field `button`.\n"]
    pub fn set_button(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.button = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.button = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardEl
{
    type O = BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardEl > ;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `image_url` after provisioning.\n"]
    pub fn image_url(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.image_url", self.base))
    }
    #[doc = "Get a reference to the value of field `subtitle` after provisioning.\n"]
    pub fn subtitle(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.subtitle", self.base))
    }
    #[doc = "Get a reference to the value of field `title` after provisioning.\n"]
    pub fn title(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.title", self.base))
    }
    #[doc = "Get a reference to the value of field `button` after provisioning.\n"]    pub fn button (& self) -> ListRef < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElButtonElRef >{
        ListRef::new(self.shared().clone(), format!("{}.button", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageEl {}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl
    BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageEl
    {
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , }
    }
}
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]
    pub fn value(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageEl {
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageEl {}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageEl
    {
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageEl {
            value: self.value,
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageElRef
    {
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]
    pub fn value(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageEl {
    #[doc = "Set the field `custom_payload`.\n"]
    pub fn set_custom_payload(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.custom_payload = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.custom_payload = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `image_response_card`.\n"]
    pub fn set_image_response_card(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.image_response_card = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.image_response_card = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `plain_text_message`.\n"]
    pub fn set_plain_text_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.plain_text_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.plain_text_message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `ssml_message`.\n"]
    pub fn set_ssml_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.ssml_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.ssml_message = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageEl {
    type O =
        BlockAssignable<Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageEl {}
impl BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageEl {
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageEl {
            custom_payload: core::default::Default::default(),
            image_response_card: core::default::Default::default(),
            plain_text_message: core::default::Default::default(),
            ssml_message: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElRef {
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"]
    pub fn custom_payload(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElCustomPayloadElRef,
    > {
        ListRef::new(
            self.shared().clone(),
            format!("{}.custom_payload", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"]    pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElImageResponseCardElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.image_response_card", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"]    pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElPlainTextMessageElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.plain_text_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"]
    pub fn ssml_message(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElSsmlMessageElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.ssml_message", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadEl {}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl
    BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadEl
    {
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadEl {
            value: self.value,
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]
    pub fn value(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl
    Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = "Set the field `image_url`.\n"]
    pub fn set_image_url(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.image_url = Some(v.into());
        self
    }
    #[doc = "Set the field `subtitle`.\n"]
    pub fn set_subtitle(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.subtitle = Some(v.into());
        self
    }
    #[doc = "Set the field `button`.\n"]
    pub fn set_button(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.button = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.button = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageEl {}
impl ToListMappable for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]
    pub fn value(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageEl {}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageEl
    {
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageEl {
            value: self.value,
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageElRef
    {
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , }
    }
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]
    pub fn value(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationEl {
    #[doc = "Set the field `custom_payload`.\n"]
    pub fn set_custom_payload(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.custom_payload = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.custom_payload = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `image_response_card`.\n"]
    pub fn set_image_response_card(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.image_response_card = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.image_response_card = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `plain_text_message`.\n"]
    pub fn set_plain_text_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.plain_text_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.plain_text_message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `ssml_message`.\n"]
    pub fn set_ssml_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.ssml_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.ssml_message = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationEl {}
impl BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationEl {
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationEl {
            custom_payload: core::default::Default::default(),
            image_response_card: core::default::Default::default(),
            plain_text_message: core::default::Default::default(),
            ssml_message: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElRef {
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"]    pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElCustomPayloadElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.custom_payload", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"]    pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElImageResponseCardElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.image_response_card", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"]    pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElPlainTextMessageElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.plain_text_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"]
    pub fn ssml_message(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElSsmlMessageElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.ssml_message", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElDynamic {
    message: Option<
        DynamicBlock<Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageEl>,
    >,
    variation: Option<
        DynamicBlock<Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationEl>,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    message: Option<Vec<Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    variation:
        Option<Vec<Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationEl>>,
    dynamic: Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElDynamic,
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupEl {
    #[doc = "Set the field `message`.\n"]
    pub fn set_message(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `variation`.\n"]
    pub fn set_variation(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.variation = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.variation = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupEl {
    type O = BlockAssignable<Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupEl {}
impl BuildLexv2modelsIntentClosingSettingElClosingResponseElMessageGroupEl {
    pub fn build(self) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupEl {
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupEl {
            message: core::default::Default::default(),
            variation: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElRef {
        Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `message` after provisioning.\n"]
    pub fn message(
        &self,
    ) -> ListRef<Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElMessageElRef> {
        ListRef::new(self.shared().clone(), format!("{}.message", self.base))
    }
    #[doc = "Get a reference to the value of field `variation` after provisioning.\n"]
    pub fn variation(
        &self,
    ) -> ListRef<Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElVariationElRef>
    {
        ListRef::new(self.shared().clone(), format!("{}.variation", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElClosingResponseElDynamic {
    message_group:
        Option<DynamicBlock<Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElClosingResponseEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    allow_interrupt: Option<PrimField<bool>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    message_group: Option<Vec<Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupEl>>,
    dynamic: Lexv2modelsIntentClosingSettingElClosingResponseElDynamic,
}
impl Lexv2modelsIntentClosingSettingElClosingResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElClosingResponseEl {
    type O = BlockAssignable<Lexv2modelsIntentClosingSettingElClosingResponseEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElClosingResponseEl {}
impl BuildLexv2modelsIntentClosingSettingElClosingResponseEl {
    pub fn build(self) -> Lexv2modelsIntentClosingSettingElClosingResponseEl {
        Lexv2modelsIntentClosingSettingElClosingResponseEl {
            allow_interrupt: core::default::Default::default(),
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElClosingResponseElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElClosingResponseElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElClosingResponseElRef {
        Lexv2modelsIntentClosingSettingElClosingResponseElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElClosingResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]
    pub fn message_group(
        &self,
    ) -> ListRef<Lexv2modelsIntentClosingSettingElClosingResponseElMessageGroupElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionEl {
    expression_string: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionEl {}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionEl {
    #[doc = ""]
    pub expression_string: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionEl {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionEl {
            expression_string: self.expression_string,
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionElRef {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `expression_string` after provisioning.\n"]
    pub fn expression_string(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.expression_string", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionEl {
    #[doc = "Set the field `slot_to_elicit`.\n"]
    pub fn set_slot_to_elicit(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.slot_to_elicit = Some(v.into());
        self
    }
    #[doc = "Set the field `suppress_next_message`.\n"]
    pub fn set_suppress_next_message(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.suppress_next_message = Some(v.into());
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl
    BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionEl
    {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionEl {
            slot_to_elicit: core::default::Default::default(),
            suppress_next_message: core::default::Default::default(),
            type_: self.type_,
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionElRef
    {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"]
    pub fn slot_to_elicit(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.slot_to_elicit", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"]
    pub fn suppress_next_message(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.suppress_next_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `type_` after provisioning.\n"]
    pub fn type_(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.type", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl
    Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[doc = "Set the field `interpreted_value`.\n"]
    pub fn set_interpreted_value(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.interpreted_value = Some(v.into());
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl {
    #[doc = "Set the field `shape`.\n"]
    pub fn set_shape(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.shape = Some(v.into());
        self
    }
    #[doc = "Set the field `value`.\n"]
    pub fn set_value(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.value = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.value = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl
    BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl
    {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl {
            map_block_key: self.map_block_key,
            shape: core::default::Default::default(),
            value: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElRef
    {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"]
    pub fn map_block_key(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.map_block_key", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `shape` after provisioning.\n"]
    pub fn shape(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.shape", self.base))
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]    pub fn value (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef >{
        ListRef::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentEl {
    #[doc = "Set the field `name`.\n"]
    pub fn set_name(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.name = Some(v.into());
        self
    }
    #[doc = "Set the field `slot`.\n"]
    pub fn set_slot(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.slot = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.slot = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentEl {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentEl {
            name: core::default::Default::default(),
            slot: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElRef {
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElRef
    {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDynamic , }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepEl {}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepEl {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepEl {
            session_attributes: core::default::Default::default(),
            dialog_action: core::default::Default::default(),
            intent: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElRef {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]
    pub fn intent(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElIntentElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupEl {
    #[doc = "Set the field `message`.\n"]
    pub fn set_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `variation`.\n"]
    pub fn set_variation(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.variation = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.variation = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupEl
{}
impl
    BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupEl
    {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupEl {
            message: core::default::Default::default(),
            variation: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElRef
    {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `message` after provisioning.\n"]    pub fn message (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef >{
        ListRef::new(self.shared().clone(), format!("{}.message", self.base))
    }
    #[doc = "Get a reference to the value of field `variation` after provisioning.\n"]    pub fn variation (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef >{
        ListRef::new(self.shared().clone(), format!("{}.variation", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElDynamic , }
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseEl {}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseEl {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseEl {
            allow_interrupt: core::default::Default::default(),
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElRef {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElDynamic {
    condition: Option<
        DynamicBlock<Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionEl>,
    >,
    next_step: Option<
        DynamicBlock<Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepEl>,
    >,
    response: Option<
        DynamicBlock<Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseEl>,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchEl {
    name: PrimField<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    condition:
        Option<Vec<Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    next_step:
        Option<Vec<Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    response:
        Option<Vec<Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseEl>>,
    dynamic: Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElDynamic,
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchEl {
    #[doc = "Set the field `condition`.\n"]
    pub fn set_condition(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.condition = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.condition = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `next_step`.\n"]
    pub fn set_next_step(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `response`.\n"]
    pub fn set_response(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.response = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchEl {
    type O = BlockAssignable<Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchEl {
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElConditionalBranchEl {
    pub fn build(self) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchEl {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchEl {
            name: self.name,
            condition: core::default::Default::default(),
            next_step: core::default::Default::default(),
            response: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElRef {
        Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
    #[doc = "Get a reference to the value of field `condition` after provisioning.\n"]
    pub fn condition(
        &self,
    ) -> ListRef<Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElConditionElRef>
    {
        ListRef::new(self.shared().clone(), format!("{}.condition", self.base))
    }
    #[doc = "Get a reference to the value of field `next_step` after provisioning.\n"]
    pub fn next_step(
        &self,
    ) -> ListRef<Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElNextStepElRef>
    {
        ListRef::new(self.shared().clone(), format!("{}.next_step", self.base))
    }
    #[doc = "Get a reference to the value of field `response` after provisioning.\n"]
    pub fn response(
        &self,
    ) -> ListRef<Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElResponseElRef>
    {
        ListRef::new(self.shared().clone(), format!("{}.response", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionEl {
    #[doc = "Set the field `slot_to_elicit`.\n"]
    pub fn set_slot_to_elicit(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.slot_to_elicit = Some(v.into());
        self
    }
    #[doc = "Set the field `suppress_next_message`.\n"]
    pub fn set_suppress_next_message(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.suppress_next_message = Some(v.into());
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionEl {
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionEl {
            slot_to_elicit: core::default::Default::default(),
            suppress_next_message: core::default::Default::default(),
            type_: self.type_,
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionElRef
    {
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"]
    pub fn slot_to_elicit(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.slot_to_elicit", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"]
    pub fn suppress_next_message(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.suppress_next_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `type_` after provisioning.\n"]
    pub fn type_(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.type", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl {
    #[doc = "Set the field `interpreted_value`.\n"]
    pub fn set_interpreted_value(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.interpreted_value = Some(v.into());
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > ;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"]
    pub fn interpreted_value(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.interpreted_value", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl {
    #[doc = "Set the field `shape`.\n"]
    pub fn set_shape(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.shape = Some(v.into());
        self
    }
    #[doc = "Set the field `value`.\n"]
    pub fn set_value(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.value = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.value = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl {
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl {
            map_block_key: self.map_block_key,
            shape: core::default::Default::default(),
            value: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElRef
    {
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"]
    pub fn map_block_key(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.map_block_key", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `shape` after provisioning.\n"]
    pub fn shape(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.shape", self.base))
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]    pub fn value (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef >{
        ListRef::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElDynamic {
    slot: Option<
        DynamicBlock<
            Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    name: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    slot: Option<
        Vec<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl>,
    >,
    dynamic: Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElDynamic,
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentEl {
    #[doc = "Set the field `name`.\n"]
    pub fn set_name(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.name = Some(v.into());
        self
    }
    #[doc = "Set the field `slot`.\n"]
    pub fn set_slot(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.slot = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.slot = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentEl {}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentEl {
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentEl {
            name: core::default::Default::default(),
            slot: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElRef {
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDynamic {
    dialog_action: Option<
        DynamicBlock<
            Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionEl,
        >,
    >,
    intent: Option<
        DynamicBlock<
            Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    session_attributes: Option<RecField<PrimField<String>>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    dialog_action: Option<
        Vec<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionEl>,
    >,
    #[serde(skip_serializing_if = "Option::is_none")]
    intent: Option<
        Vec<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentEl>,
    >,
    dynamic: Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDynamic,
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepEl {
    type O =
        BlockAssignable<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepEl {}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepEl {
    pub fn build(self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepEl {
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepEl {
            session_attributes: core::default::Default::default(),
            dialog_action: core::default::Default::default(),
            intent: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElRef {
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]
    pub fn dialog_action(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElDialogActionElRef,
    > {
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]
    pub fn intent(
        &self,
    ) -> ListRef<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElIntentElRef>
    {
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic , }
impl
    Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{
    #[doc = "Set the field `custom_payload`.\n"]
    pub fn set_custom_payload(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.custom_payload = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.custom_payload = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `image_response_card`.\n"]
    pub fn set_image_response_card(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.image_response_card = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.image_response_card = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `plain_text_message`.\n"]
    pub fn set_plain_text_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.plain_text_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.plain_text_message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `ssml_message`.\n"]
    pub fn set_ssml_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.ssml_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.ssml_message = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic , }
impl
    Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{
    #[doc = "Set the field `custom_payload`.\n"]
    pub fn set_custom_payload(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.custom_payload = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.custom_payload = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `image_response_card`.\n"]
    pub fn set_image_response_card(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.image_response_card = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.image_response_card = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `plain_text_message`.\n"]
    pub fn set_plain_text_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.plain_text_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.plain_text_message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `ssml_message`.\n"]
    pub fn set_ssml_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.ssml_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.ssml_message = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupEl {
    #[doc = "Set the field `message`.\n"]
    pub fn set_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `variation`.\n"]
    pub fn set_variation(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.variation = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.variation = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupEl {
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupEl {
            message: core::default::Default::default(),
            variation: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElRef
    {
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `message` after provisioning.\n"]    pub fn message (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef >{
        ListRef::new(self.shared().clone(), format!("{}.message", self.base))
    }
    #[doc = "Get a reference to the value of field `variation` after provisioning.\n"]    pub fn variation (& self) -> ListRef < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef >{
        ListRef::new(self.shared().clone(), format!("{}.variation", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElDynamic {
    message_group: Option<
        DynamicBlock<
            Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    allow_interrupt: Option<PrimField<bool>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    message_group: Option<
        Vec<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupEl>,
    >,
    dynamic: Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElDynamic,
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseEl {
    type O =
        BlockAssignable<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseEl {}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseEl {
    pub fn build(self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseEl {
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseEl {
            allow_interrupt: core::default::Default::default(),
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElRef {
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]
    pub fn message_group(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElMessageGroupElRef,
    > {
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElDynamic {
    next_step: Option<
        DynamicBlock<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepEl>,
    >,
    response: Option<
        DynamicBlock<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseEl>,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    next_step: Option<Vec<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    response: Option<Vec<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseEl>>,
    dynamic: Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElDynamic,
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchEl {
    #[doc = "Set the field `next_step`.\n"]
    pub fn set_next_step(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `response`.\n"]
    pub fn set_response(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.response = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchEl {
    type O = BlockAssignable<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchEl {}
impl BuildLexv2modelsIntentClosingSettingElConditionalElDefaultBranchEl {
    pub fn build(self) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchEl {
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchEl {
            next_step: core::default::Default::default(),
            response: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElRef {
        Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `next_step` after provisioning.\n"]
    pub fn next_step(
        &self,
    ) -> ListRef<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElNextStepElRef> {
        ListRef::new(self.shared().clone(), format!("{}.next_step", self.base))
    }
    #[doc = "Get a reference to the value of field `response` after provisioning.\n"]
    pub fn response(
        &self,
    ) -> ListRef<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElResponseElRef> {
        ListRef::new(self.shared().clone(), format!("{}.response", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElConditionalElDynamic {
    conditional_branch:
        Option<DynamicBlock<Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchEl>>,
    default_branch:
        Option<DynamicBlock<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElConditionalEl {
    active: PrimField<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    conditional_branch:
        Option<Vec<Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    default_branch: Option<Vec<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchEl>>,
    dynamic: Lexv2modelsIntentClosingSettingElConditionalElDynamic,
}
impl Lexv2modelsIntentClosingSettingElConditionalEl {
    #[doc = "Set the field `conditional_branch`.\n"]
    pub fn set_conditional_branch(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.conditional_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.conditional_branch = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `default_branch`.\n"]
    pub fn set_default_branch(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.default_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.default_branch = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElConditionalEl {
    type O = BlockAssignable<Lexv2modelsIntentClosingSettingElConditionalEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElConditionalEl {
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentClosingSettingElConditionalEl {
    pub fn build(self) -> Lexv2modelsIntentClosingSettingElConditionalEl {
        Lexv2modelsIntentClosingSettingElConditionalEl {
            active: self.active,
            conditional_branch: core::default::Default::default(),
            default_branch: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElConditionalElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElConditionalElRef {
    fn new(shared: StackShared, base: String) -> Lexv2modelsIntentClosingSettingElConditionalElRef {
        Lexv2modelsIntentClosingSettingElConditionalElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElConditionalElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `active` after provisioning.\n"]
    pub fn active(&self) -> PrimExpr<bool> {
        PrimExpr::new(self.shared().clone(), format!("{}.active", self.base))
    }
    #[doc = "Get a reference to the value of field `conditional_branch` after provisioning.\n"]
    pub fn conditional_branch(
        &self,
    ) -> ListRef<Lexv2modelsIntentClosingSettingElConditionalElConditionalBranchElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.conditional_branch", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `default_branch` after provisioning.\n"]
    pub fn default_branch(
        &self,
    ) -> ListRef<Lexv2modelsIntentClosingSettingElConditionalElDefaultBranchElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.default_branch", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElNextStepElDialogActionEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentClosingSettingElNextStepElDialogActionEl {
    #[doc = "Set the field `slot_to_elicit`.\n"]
    pub fn set_slot_to_elicit(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.slot_to_elicit = Some(v.into());
        self
    }
    #[doc = "Set the field `suppress_next_message`.\n"]
    pub fn set_suppress_next_message(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.suppress_next_message = Some(v.into());
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElNextStepElDialogActionEl {
    type O = BlockAssignable<Lexv2modelsIntentClosingSettingElNextStepElDialogActionEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElNextStepElDialogActionEl {
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElNextStepElDialogActionEl {
    pub fn build(self) -> Lexv2modelsIntentClosingSettingElNextStepElDialogActionEl {
        Lexv2modelsIntentClosingSettingElNextStepElDialogActionEl {
            slot_to_elicit: core::default::Default::default(),
            suppress_next_message: core::default::Default::default(),
            type_: self.type_,
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElNextStepElDialogActionElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElNextStepElDialogActionElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElNextStepElDialogActionElRef {
        Lexv2modelsIntentClosingSettingElNextStepElDialogActionElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElNextStepElDialogActionElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"]
    pub fn slot_to_elicit(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.slot_to_elicit", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"]
    pub fn suppress_next_message(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.suppress_next_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `type_` after provisioning.\n"]
    pub fn type_(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.type", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueEl {
    #[doc = "Set the field `interpreted_value`.\n"]
    pub fn set_interpreted_value(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.interpreted_value = Some(v.into());
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueEl {
    type O = BlockAssignable<Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueEl {}
impl BuildLexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueEl {
    pub fn build(self) -> Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueEl {
        Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueEl {
            interpreted_value: core::default::Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueElRef {
        Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"]
    pub fn interpreted_value(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.interpreted_value", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElDynamic {
    value: Option<DynamicBlock<Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotEl {
    map_block_key: PrimField<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    shape: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    value: Option<Vec<Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueEl>>,
    dynamic: Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElDynamic,
}
impl Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotEl {
    #[doc = "Set the field `shape`.\n"]
    pub fn set_shape(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.shape = Some(v.into());
        self
    }
    #[doc = "Set the field `value`.\n"]
    pub fn set_value(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.value = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.value = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotEl {
    type O = BlockAssignable<Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElNextStepElIntentElSlotEl {
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentClosingSettingElNextStepElIntentElSlotEl {
    pub fn build(self) -> Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotEl {
        Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotEl {
            map_block_key: self.map_block_key,
            shape: core::default::Default::default(),
            value: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElRef {
        Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"]
    pub fn map_block_key(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.map_block_key", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `shape` after provisioning.\n"]
    pub fn shape(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.shape", self.base))
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]
    pub fn value(
        &self,
    ) -> ListRef<Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotElValueElRef> {
        ListRef::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElNextStepElIntentElDynamic {
    slot: Option<DynamicBlock<Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElNextStepElIntentEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    name: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    slot: Option<Vec<Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotEl>>,
    dynamic: Lexv2modelsIntentClosingSettingElNextStepElIntentElDynamic,
}
impl Lexv2modelsIntentClosingSettingElNextStepElIntentEl {
    #[doc = "Set the field `name`.\n"]
    pub fn set_name(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.name = Some(v.into());
        self
    }
    #[doc = "Set the field `slot`.\n"]
    pub fn set_slot(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentClosingSettingElNextStepElIntentElSlotEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.slot = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.slot = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElNextStepElIntentEl {
    type O = BlockAssignable<Lexv2modelsIntentClosingSettingElNextStepElIntentEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElNextStepElIntentEl {}
impl BuildLexv2modelsIntentClosingSettingElNextStepElIntentEl {
    pub fn build(self) -> Lexv2modelsIntentClosingSettingElNextStepElIntentEl {
        Lexv2modelsIntentClosingSettingElNextStepElIntentEl {
            name: core::default::Default::default(),
            slot: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElNextStepElIntentElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElNextStepElIntentElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentClosingSettingElNextStepElIntentElRef {
        Lexv2modelsIntentClosingSettingElNextStepElIntentElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElNextStepElIntentElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElNextStepElDynamic {
    dialog_action: Option<DynamicBlock<Lexv2modelsIntentClosingSettingElNextStepElDialogActionEl>>,
    intent: Option<DynamicBlock<Lexv2modelsIntentClosingSettingElNextStepElIntentEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingElNextStepEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    session_attributes: Option<RecField<PrimField<String>>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    dialog_action: Option<Vec<Lexv2modelsIntentClosingSettingElNextStepElDialogActionEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    intent: Option<Vec<Lexv2modelsIntentClosingSettingElNextStepElIntentEl>>,
    dynamic: Lexv2modelsIntentClosingSettingElNextStepElDynamic,
}
impl Lexv2modelsIntentClosingSettingElNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentClosingSettingElNextStepElDialogActionEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentClosingSettingElNextStepElIntentEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingElNextStepEl {
    type O = BlockAssignable<Lexv2modelsIntentClosingSettingElNextStepEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingElNextStepEl {}
impl BuildLexv2modelsIntentClosingSettingElNextStepEl {
    pub fn build(self) -> Lexv2modelsIntentClosingSettingElNextStepEl {
        Lexv2modelsIntentClosingSettingElNextStepEl {
            session_attributes: core::default::Default::default(),
            dialog_action: core::default::Default::default(),
            intent: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElNextStepElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElNextStepElRef {
    fn new(shared: StackShared, base: String) -> Lexv2modelsIntentClosingSettingElNextStepElRef {
        Lexv2modelsIntentClosingSettingElNextStepElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElNextStepElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]
    pub fn dialog_action(
        &self,
    ) -> ListRef<Lexv2modelsIntentClosingSettingElNextStepElDialogActionElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]
    pub fn intent(&self) -> ListRef<Lexv2modelsIntentClosingSettingElNextStepElIntentElRef> {
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentClosingSettingElDynamic {
    closing_response: Option<DynamicBlock<Lexv2modelsIntentClosingSettingElClosingResponseEl>>,
    conditional: Option<DynamicBlock<Lexv2modelsIntentClosingSettingElConditionalEl>>,
    next_step: Option<DynamicBlock<Lexv2modelsIntentClosingSettingElNextStepEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentClosingSettingEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    active: Option<PrimField<bool>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    closing_response: Option<Vec<Lexv2modelsIntentClosingSettingElClosingResponseEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    conditional: Option<Vec<Lexv2modelsIntentClosingSettingElConditionalEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    next_step: Option<Vec<Lexv2modelsIntentClosingSettingElNextStepEl>>,
    dynamic: Lexv2modelsIntentClosingSettingElDynamic,
}
impl Lexv2modelsIntentClosingSettingEl {
    #[doc = "Set the field `active`.\n"]
    pub fn set_active(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.active = Some(v.into());
        self
    }
    #[doc = "Set the field `closing_response`.\n"]
    pub fn set_closing_response(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentClosingSettingElClosingResponseEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.closing_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.closing_response = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `conditional`.\n"]
    pub fn set_conditional(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentClosingSettingElConditionalEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.conditional = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.conditional = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `next_step`.\n"]
    pub fn set_next_step(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentClosingSettingElNextStepEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.next_step = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentClosingSettingEl {
    type O = BlockAssignable<Lexv2modelsIntentClosingSettingEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentClosingSettingEl {}
impl BuildLexv2modelsIntentClosingSettingEl {
    pub fn build(self) -> Lexv2modelsIntentClosingSettingEl {
        Lexv2modelsIntentClosingSettingEl {
            active: core::default::Default::default(),
            closing_response: core::default::Default::default(),
            conditional: core::default::Default::default(),
            next_step: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentClosingSettingElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentClosingSettingElRef {
    fn new(shared: StackShared, base: String) -> Lexv2modelsIntentClosingSettingElRef {
        Lexv2modelsIntentClosingSettingElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentClosingSettingElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `active` after provisioning.\n"]
    pub fn active(&self) -> PrimExpr<bool> {
        PrimExpr::new(self.shared().clone(), format!("{}.active", self.base))
    }
    #[doc = "Get a reference to the value of field `closing_response` after provisioning.\n"]
    pub fn closing_response(
        &self,
    ) -> ListRef<Lexv2modelsIntentClosingSettingElClosingResponseElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.closing_response", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `conditional` after provisioning.\n"]
    pub fn conditional(&self) -> ListRef<Lexv2modelsIntentClosingSettingElConditionalElRef> {
        ListRef::new(self.shared().clone(), format!("{}.conditional", self.base))
    }
    #[doc = "Get a reference to the value of field `next_step` after provisioning.\n"]
    pub fn next_step(&self) -> ListRef<Lexv2modelsIntentClosingSettingElNextStepElRef> {
        ListRef::new(self.shared().clone(), format!("{}.next_step", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl
{
    expression_string: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl
{
    #[doc = ""]
    pub expression_string: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl { expression_string : self . expression_string , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `expression_string` after provisioning.\n"] pub fn expression_string (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.expression_string" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElDynamic { condition : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl >> , next_step : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl { name : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] condition : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl > > , # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl { # [doc = "Set the field `condition`.\n"] pub fn set_condition (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . condition = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . condition = Some (d) ; } } self } # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl
{
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl { name : self . name , condition : core :: default :: Default :: default () , next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } # [doc = "Get a reference to the value of field `condition` after provisioning.\n"] pub fn condition (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.condition" , self . base)) } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElDynamic { next_step : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl { # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl { # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl { next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDynamic { conditional_branch : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl >> , default_branch : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl { active : PrimField < bool > , # [serde (skip_serializing_if = "Option::is_none")] conditional_branch : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl > > , # [serde (skip_serializing_if = "Option::is_none")] default_branch : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDynamic , }
impl
    Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl
{
    #[doc = "Set the field `conditional_branch`.\n"]
    pub fn set_conditional_branch(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.conditional_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.conditional_branch = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `default_branch`.\n"]
    pub fn set_default_branch(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.default_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.default_branch = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl
{
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl { active : self . active , conditional_branch : core :: default :: Default :: default () , default_branch : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `active` after provisioning.\n"] pub fn active (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.active" , self . base)) } # [doc = "Get a reference to the value of field `conditional_branch` after provisioning.\n"] pub fn conditional_branch (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.conditional_branch" , self . base)) } # [doc = "Get a reference to the value of field `default_branch` after provisioning.\n"] pub fn default_branch (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.default_branch" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl
{
    type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl > ;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]    pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElRef >{
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl
{
    type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl > ;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl
{
    expression_string: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl
{
    #[doc = ""]
    pub expression_string: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl { expression_string : self . expression_string , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `expression_string` after provisioning.\n"] pub fn expression_string (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.expression_string" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElDynamic { condition : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl >> , next_step : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl { name : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] condition : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl > > , # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl { # [doc = "Set the field `condition`.\n"] pub fn set_condition (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . condition = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . condition = Some (d) ; } } self } # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl
{
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl { name : self . name , condition : core :: default :: Default :: default () , next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } # [doc = "Get a reference to the value of field `condition` after provisioning.\n"] pub fn condition (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.condition" , self . base)) } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElDynamic { next_step : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl { # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl { # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl { next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDynamic { conditional_branch : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl >> , default_branch : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl { active : PrimField < bool > , # [serde (skip_serializing_if = "Option::is_none")] conditional_branch : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl > > , # [serde (skip_serializing_if = "Option::is_none")] default_branch : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDynamic , }
impl
    Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl
{
    #[doc = "Set the field `conditional_branch`.\n"]
    pub fn set_conditional_branch(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.conditional_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.conditional_branch = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `default_branch`.\n"]
    pub fn set_default_branch(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.default_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.default_branch = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl
{
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl { active : self . active , conditional_branch : core :: default :: Default :: default () , default_branch : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `active` after provisioning.\n"] pub fn active (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.active" , self . base)) } # [doc = "Get a reference to the value of field `conditional_branch` after provisioning.\n"] pub fn conditional_branch (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.conditional_branch" , self . base)) } # [doc = "Get a reference to the value of field `default_branch` after provisioning.\n"] pub fn default_branch (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.default_branch" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl
{
    type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl > ;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]    pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElRef >{
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl
{
    type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl > ;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl
{
    expression_string: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl
{
    #[doc = ""]
    pub expression_string: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { expression_string : self . expression_string , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `expression_string` after provisioning.\n"] pub fn expression_string (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.expression_string" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElDynamic { condition : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl >> , next_step : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl { name : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] condition : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl > > , # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl { # [doc = "Set the field `condition`.\n"] pub fn set_condition (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . condition = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . condition = Some (d) ; } } self } # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl
{
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl { name : self . name , condition : core :: default :: Default :: default () , next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } # [doc = "Get a reference to the value of field `condition` after provisioning.\n"] pub fn condition (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.condition" , self . base)) } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElDynamic { next_step : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl { # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl { # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl { next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDynamic { conditional_branch : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl >> , default_branch : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl { active : PrimField < bool > , # [serde (skip_serializing_if = "Option::is_none")] conditional_branch : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl > > , # [serde (skip_serializing_if = "Option::is_none")] default_branch : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDynamic , }
impl
    Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl
{
    #[doc = "Set the field `conditional_branch`.\n"]
    pub fn set_conditional_branch(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.conditional_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.conditional_branch = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `default_branch`.\n"]
    pub fn set_default_branch(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.default_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.default_branch = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl
{
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl { active : self . active , conditional_branch : core :: default :: Default :: default () , default_branch : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `active` after provisioning.\n"] pub fn active (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.active" , self . base)) } # [doc = "Get a reference to the value of field `conditional_branch` after provisioning.\n"] pub fn conditional_branch (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.conditional_branch" , self . base)) } # [doc = "Get a reference to the value of field `default_branch` after provisioning.\n"] pub fn default_branch (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.default_branch" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl
{
    type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl > ;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]    pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElRef >{
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl
{
    type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl > ;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElRef { Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElDynamic { failure_conditional : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl >> , failure_next_step : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl >> , failure_response : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl >> , success_conditional : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl >> , success_next_step : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl >> , success_response : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl >> , timeout_conditional : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl >> , timeout_next_step : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl >> , timeout_response : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationEl { # [serde (skip_serializing_if = "Option::is_none")] failure_conditional : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl > > , # [serde (skip_serializing_if = "Option::is_none")] failure_next_step : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] failure_response : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl > > , # [serde (skip_serializing_if = "Option::is_none")] success_conditional : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl > > , # [serde (skip_serializing_if = "Option::is_none")] success_next_step : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] success_response : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl > > , # [serde (skip_serializing_if = "Option::is_none")] timeout_conditional : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl > > , # [serde (skip_serializing_if = "Option::is_none")] timeout_next_step : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] timeout_response : Option < Vec < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationEl {
    #[doc = "Set the field `failure_conditional`.\n"]
    pub fn set_failure_conditional(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.failure_conditional = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.failure_conditional = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `failure_next_step`.\n"]
    pub fn set_failure_next_step(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.failure_next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.failure_next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `failure_response`.\n"]
    pub fn set_failure_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.failure_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.failure_response = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `success_conditional`.\n"]
    pub fn set_success_conditional(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.success_conditional = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.success_conditional = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `success_next_step`.\n"]
    pub fn set_success_next_step(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.success_next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.success_next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `success_response`.\n"]
    pub fn set_success_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.success_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.success_response = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `timeout_conditional`.\n"]
    pub fn set_timeout_conditional(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.timeout_conditional = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.timeout_conditional = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `timeout_next_step`.\n"]
    pub fn set_timeout_next_step(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.timeout_next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.timeout_next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `timeout_response`.\n"]
    pub fn set_timeout_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.timeout_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.timeout_response = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationEl {}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationEl {
        Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationEl {
            failure_conditional: core::default::Default::default(),
            failure_next_step: core::default::Default::default(),
            failure_response: core::default::Default::default(),
            success_conditional: core::default::Default::default(),
            success_next_step: core::default::Default::default(),
            success_response: core::default::Default::default(),
            timeout_conditional: core::default::Default::default(),
            timeout_next_step: core::default::Default::default(),
            timeout_response: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElRef {
        Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `failure_conditional` after provisioning.\n"]    pub fn failure_conditional (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.failure_conditional", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `failure_next_step` after provisioning.\n"]    pub fn failure_next_step (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.failure_next_step", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `failure_response` after provisioning.\n"]    pub fn failure_response (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.failure_response", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `success_conditional` after provisioning.\n"]    pub fn success_conditional (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.success_conditional", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `success_next_step` after provisioning.\n"]    pub fn success_next_step (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.success_next_step", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `success_response` after provisioning.\n"]    pub fn success_response (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.success_response", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `timeout_conditional` after provisioning.\n"]    pub fn timeout_conditional (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.timeout_conditional", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `timeout_next_step` after provisioning.\n"]    pub fn timeout_next_step (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.timeout_next_step", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `timeout_response` after provisioning.\n"]    pub fn timeout_response (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.timeout_response", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElCodeHookElDynamic {
    post_code_hook_specification: Option<
        DynamicBlock<Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationEl>,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookEl {
    active: PrimField<bool>,
    enable_code_hook_invocation: PrimField<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    invocation_label: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    post_code_hook_specification:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElCodeHookElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookEl {
    #[doc = "Set the field `invocation_label`.\n"]
    pub fn set_invocation_label(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.invocation_label = Some(v.into());
        self
    }
    #[doc = "Set the field `post_code_hook_specification`.\n"]
    pub fn set_post_code_hook_specification(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.post_code_hook_specification = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.post_code_hook_specification = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElCodeHookEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElCodeHookEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElCodeHookEl {
    #[doc = ""]
    pub active: PrimField<bool>,
    #[doc = ""]
    pub enable_code_hook_invocation: PrimField<bool>,
}
impl BuildLexv2modelsIntentConfirmationSettingElCodeHookEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElCodeHookEl {
        Lexv2modelsIntentConfirmationSettingElCodeHookEl {
            active: self.active,
            enable_code_hook_invocation: self.enable_code_hook_invocation,
            invocation_label: core::default::Default::default(),
            post_code_hook_specification: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElCodeHookElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElCodeHookElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElCodeHookElRef {
        Lexv2modelsIntentConfirmationSettingElCodeHookElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElCodeHookElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `active` after provisioning.\n"]
    pub fn active(&self) -> PrimExpr<bool> {
        PrimExpr::new(self.shared().clone(), format!("{}.active", self.base))
    }
    #[doc = "Get a reference to the value of field `enable_code_hook_invocation` after provisioning.\n"]
    pub fn enable_code_hook_invocation(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.enable_code_hook_invocation", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `invocation_label` after provisioning.\n"]
    pub fn invocation_label(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.invocation_label", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `post_code_hook_specification` after provisioning.\n"]
    pub fn post_code_hook_specification(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElCodeHookElPostCodeHookSpecificationElRef>
    {
        ListRef::new(
            self.shared().clone(),
            format!("{}.post_code_hook_specification", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionEl
{
    expression_string: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionEl {}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionEl
{
    #[doc = ""]
    pub expression_string: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionEl { expression_string : self . expression_string , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `expression_string` after provisioning.\n"]
    pub fn expression_string(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.expression_string", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepEl
{
    type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepEl > ;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]    pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElIntentElRef >{
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseEl
{
    type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseEl > ;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElDynamic { condition : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionEl >> , next_step : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchEl { name : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] condition : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionEl > > , # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchEl {
    #[doc = "Set the field `condition`.\n"]
    pub fn set_condition(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.condition = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.condition = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `next_step`.\n"]
    pub fn set_next_step(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `response`.\n"]
    pub fn set_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.response = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchEl {
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchEl {
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchEl {
            name: self.name,
            condition: core::default::Default::default(),
            next_step: core::default::Default::default(),
            response: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElRef {
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
    #[doc = "Get a reference to the value of field `condition` after provisioning.\n"]    pub fn condition (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElConditionElRef >{
        ListRef::new(self.shared().clone(), format!("{}.condition", self.base))
    }
    #[doc = "Get a reference to the value of field `next_step` after provisioning.\n"]    pub fn next_step (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElNextStepElRef >{
        ListRef::new(self.shared().clone(), format!("{}.next_step", self.base))
    }
    #[doc = "Get a reference to the value of field `response` after provisioning.\n"]    pub fn response (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElResponseElRef >{
        ListRef::new(self.shared().clone(), format!("{}.response", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElDynamic , }
impl
    Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentEl
{
    #[doc = "Set the field `name`.\n"]
    pub fn set_name(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.name = Some(v.into());
        self
    }
    #[doc = "Set the field `slot`.\n"]
    pub fn set_slot(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElSlotEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.slot = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.slot = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepEl
    {
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepEl {
            session_attributes: core::default::Default::default(),
            dialog_action: core::default::Default::default(),
            intent: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElRef
    {
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElRef { shared : shared , base : base . to_string () , }
    }
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]    pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElIntentElRef >{
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseEl
    {
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseEl {
            allow_interrupt: core::default::Default::default(),
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElRef
    {
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElRef { shared : shared , base : base . to_string () , }
    }
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElDynamic { next_step : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchEl { # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchEl {
    #[doc = "Set the field `next_step`.\n"]
    pub fn set_next_step(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `response`.\n"]
    pub fn set_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.response = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchEl {}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchEl {
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchEl {
            next_step: core::default::Default::default(),
            response: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElRef {
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `next_step` after provisioning.\n"]
    pub fn next_step(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElNextStepElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.next_step", self.base))
    }
    #[doc = "Get a reference to the value of field `response` after provisioning.\n"]
    pub fn response(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElResponseElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.response", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDynamic {
    conditional_branch: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchEl,
        >,
    >,
    default_branch: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalEl {
    active: PrimField<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    conditional_branch: Option<
        Vec<Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchEl>,
    >,
    #[serde(skip_serializing_if = "Option::is_none")]
    default_branch:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalEl {
    #[doc = "Set the field `conditional_branch`.\n"]
    pub fn set_conditional_branch(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.conditional_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.conditional_branch = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `default_branch`.\n"]
    pub fn set_default_branch(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.default_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.default_branch = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElConfirmationConditionalEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalEl {
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationConditionalEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalEl {
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalEl {
            active: self.active,
            conditional_branch: core::default::Default::default(),
            default_branch: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElRef {
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `active` after provisioning.\n"]
    pub fn active(&self) -> PrimExpr<bool> {
        PrimExpr::new(self.shared().clone(), format!("{}.active", self.base))
    }
    #[doc = "Get a reference to the value of field `conditional_branch` after provisioning.\n"]
    pub fn conditional_branch(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElConditionalBranchElRef,
    > {
        ListRef::new(
            self.shared().clone(),
            format!("{}.conditional_branch", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `default_branch` after provisioning.\n"]
    pub fn default_branch(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElDefaultBranchElRef>
    {
        ListRef::new(
            self.shared().clone(),
            format!("{}.default_branch", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionEl {
    #[doc = "Set the field `slot_to_elicit`.\n"]
    pub fn set_slot_to_elicit(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.slot_to_elicit = Some(v.into());
        self
    }
    #[doc = "Set the field `suppress_next_message`.\n"]
    pub fn set_suppress_next_message(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.suppress_next_message = Some(v.into());
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionEl {
    type O =
        BlockAssignable<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionEl {
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionEl {
        Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionEl {
            slot_to_elicit: core::default::Default::default(),
            suppress_next_message: core::default::Default::default(),
            type_: self.type_,
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionElRef {
        Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"]
    pub fn slot_to_elicit(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.slot_to_elicit", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"]
    pub fn suppress_next_message(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.suppress_next_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `type_` after provisioning.\n"]
    pub fn type_(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.type", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueEl {
    #[doc = "Set the field `interpreted_value`.\n"]
    pub fn set_interpreted_value(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.interpreted_value = Some(v.into());
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueEl {
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueEl {
        Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueEl {
            interpreted_value: core::default::Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueElRef {
        Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"]
    pub fn interpreted_value(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.interpreted_value", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElDynamic {
    value: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotEl {
    map_block_key: PrimField<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    shape: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    value: Option<
        Vec<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueEl>,
    >,
    dynamic: Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotEl {
    #[doc = "Set the field `shape`.\n"]
    pub fn set_shape(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.shape = Some(v.into());
        self
    }
    #[doc = "Set the field `value`.\n"]
    pub fn set_value(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.value = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.value = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotEl {
    type O =
        BlockAssignable<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotEl {
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotEl {
        Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotEl {
            map_block_key: self.map_block_key,
            shape: core::default::Default::default(),
            value: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElRef {
        Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"]
    pub fn map_block_key(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.map_block_key", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `shape` after provisioning.\n"]
    pub fn shape(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.shape", self.base))
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]
    pub fn value(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotElValueElRef>
    {
        ListRef::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElDynamic {
    slot: Option<
        DynamicBlock<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotEl>,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    name: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    slot: Option<Vec<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentEl {
    #[doc = "Set the field `name`.\n"]
    pub fn set_name(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.name = Some(v.into());
        self
    }
    #[doc = "Set the field `slot`.\n"]
    pub fn set_slot(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElSlotEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.slot = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.slot = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentEl {}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentEl {
        Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentEl {
            name: core::default::Default::default(),
            slot: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElRef {
        Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDynamic {
    dialog_action: Option<
        DynamicBlock<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionEl>,
    >,
    intent:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationNextStepEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    session_attributes: Option<RecField<PrimField<String>>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    dialog_action:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    intent: Option<Vec<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v: impl Into<
            BlockAssignable<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentEl>,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationNextStepEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationNextStepEl {}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationNextStepEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElConfirmationNextStepEl {
        Lexv2modelsIntentConfirmationSettingElConfirmationNextStepEl {
            session_attributes: core::default::Default::default(),
            dialog_action: core::default::Default::default(),
            intent: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElRef {
        Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]
    pub fn dialog_action(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElDialogActionElRef>
    {
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]
    pub fn intent(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElIntentElRef> {
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl
    Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageEl
{
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageEl {
    #[doc = "Set the field `custom_payload`.\n"]
    pub fn set_custom_payload(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.custom_payload = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.custom_payload = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `image_response_card`.\n"]
    pub fn set_image_response_card(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.image_response_card = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.image_response_card = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `plain_text_message`.\n"]
    pub fn set_plain_text_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.plain_text_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.plain_text_message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `ssml_message`.\n"]
    pub fn set_ssml_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.ssml_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.ssml_message = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageEl {
        Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageEl {
            custom_payload: core::default::Default::default(),
            image_response_card: core::default::Default::default(),
            plain_text_message: core::default::Default::default(),
            ssml_message: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElRef {
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElRef
    {
        Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"]    pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElCustomPayloadElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.custom_payload", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"]    pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElImageResponseCardElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.image_response_card", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"]    pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElPlainTextMessageElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.plain_text_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"]    pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElSsmlMessageElRef >{
        ListRef::new(self.shared().clone(), format!("{}.ssml_message", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationEl {
    #[doc = "Set the field `custom_payload`.\n"]
    pub fn set_custom_payload(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.custom_payload = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.custom_payload = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `image_response_card`.\n"]
    pub fn set_image_response_card(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.image_response_card = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.image_response_card = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `plain_text_message`.\n"]
    pub fn set_plain_text_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.plain_text_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.plain_text_message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `ssml_message`.\n"]
    pub fn set_ssml_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.ssml_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.ssml_message = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationEl {
        Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationEl {
            custom_payload: core::default::Default::default(),
            image_response_card: core::default::Default::default(),
            plain_text_message: core::default::Default::default(),
            ssml_message: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElRef
    {
        Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"]    pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElCustomPayloadElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.custom_payload", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"]    pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElImageResponseCardElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.image_response_card", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"]    pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElPlainTextMessageElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.plain_text_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"]    pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElSsmlMessageElRef >{
        ListRef::new(self.shared().clone(), format!("{}.ssml_message", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElDynamic {
    message: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageEl,
        >,
    >,
    variation: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    message: Option<
        Vec<Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageEl>,
    >,
    #[serde(skip_serializing_if = "Option::is_none")]
    variation: Option<
        Vec<Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationEl>,
    >,
    dynamic: Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupEl {
    #[doc = "Set the field `message`.\n"]
    pub fn set_message(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `variation`.\n"]
    pub fn set_variation(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.variation = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.variation = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupEl {
    type O =
        BlockAssignable<Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupEl {}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupEl {
        Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupEl {
            message: core::default::Default::default(),
            variation: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElRef {
        Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `message` after provisioning.\n"]
    pub fn message(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElMessageElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.message", self.base))
    }
    #[doc = "Get a reference to the value of field `variation` after provisioning.\n"]
    pub fn variation(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElVariationElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.variation", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElDynamic {
    message_group: Option<
        DynamicBlock<Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupEl>,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    allow_interrupt: Option<PrimField<bool>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    message_group:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElConfirmationResponseElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElConfirmationResponseEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElConfirmationResponseEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseEl {}
impl BuildLexv2modelsIntentConfirmationSettingElConfirmationResponseEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseEl {
        Lexv2modelsIntentConfirmationSettingElConfirmationResponseEl {
            allow_interrupt: core::default::Default::default(),
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElConfirmationResponseElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElConfirmationResponseElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElConfirmationResponseElRef {
        Lexv2modelsIntentConfirmationSettingElConfirmationResponseElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElConfirmationResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]
    pub fn message_group(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElConfirmationResponseElMessageGroupElRef>
    {
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionEl
{
    expression_string: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionEl {}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionEl
{
    type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionEl > ;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionEl
{
    #[doc = ""]
    pub expression_string: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionEl { expression_string : self . expression_string , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `expression_string` after provisioning.\n"]
    pub fn expression_string(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.expression_string", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepEl
{}
impl
    BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepEl
    {
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]    pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElIntentElRef >{
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseEl
{}
impl
    BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseEl
    {
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElDynamic { condition : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionEl >> , next_step : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchEl { name : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] condition : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionEl > > , # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchEl {
    #[doc = "Set the field `condition`.\n"]
    pub fn set_condition(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.condition = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.condition = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `next_step`.\n"]
    pub fn set_next_step(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `response`.\n"]
    pub fn set_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.response = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchEl {
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchEl {
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchEl {
            name: self.name,
            condition: core::default::Default::default(),
            next_step: core::default::Default::default(),
            response: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElRef {
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
    #[doc = "Get a reference to the value of field `condition` after provisioning.\n"]    pub fn condition (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElConditionElRef >{
        ListRef::new(self.shared().clone(), format!("{}.condition", self.base))
    }
    #[doc = "Get a reference to the value of field `next_step` after provisioning.\n"]    pub fn next_step (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElNextStepElRef >{
        ListRef::new(self.shared().clone(), format!("{}.next_step", self.base))
    }
    #[doc = "Get a reference to the value of field `response` after provisioning.\n"]    pub fn response (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElResponseElRef >{
        ListRef::new(self.shared().clone(), format!("{}.response", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElDynamic , }
impl
    Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentEl
{
    #[doc = "Set the field `name`.\n"]
    pub fn set_name(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.name = Some(v.into());
        self
    }
    #[doc = "Set the field `slot`.\n"]
    pub fn set_slot(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElSlotEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.slot = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.slot = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepEl
    {
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepEl {
            session_attributes: core::default::Default::default(),
            dialog_action: core::default::Default::default(),
            intent: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElRef
    {
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]    pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElIntentElRef >{
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseEl
    {
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseEl {
            allow_interrupt: core::default::Default::default(),
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElRef
    {
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElDynamic {
    next_step: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepEl,
        >,
    >,
    response: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    next_step: Option<
        Vec<
            Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepEl,
        >,
    >,
    #[serde(skip_serializing_if = "Option::is_none")]
    response: Option<
        Vec<
            Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseEl,
        >,
    >,
    dynamic: Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchEl {
    #[doc = "Set the field `next_step`.\n"]
    pub fn set_next_step(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `response`.\n"]
    pub fn set_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.response = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchEl {}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchEl {
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchEl {
            next_step: core::default::Default::default(),
            response: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElRef {
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `next_step` after provisioning.\n"]
    pub fn next_step(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElNextStepElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.next_step", self.base))
    }
    #[doc = "Get a reference to the value of field `response` after provisioning.\n"]
    pub fn response(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElResponseElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.response", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDynamic {
    conditional_branch: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchEl,
        >,
    >,
    default_branch: Option<
        DynamicBlock<Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchEl>,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalEl {
    active: PrimField<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    conditional_branch: Option<
        Vec<Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchEl>,
    >,
    #[serde(skip_serializing_if = "Option::is_none")]
    default_branch:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalEl {
    #[doc = "Set the field `conditional_branch`.\n"]
    pub fn set_conditional_branch(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.conditional_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.conditional_branch = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `default_branch`.\n"]
    pub fn set_default_branch(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.default_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.default_branch = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElDeclinationConditionalEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalEl {
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationConditionalEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalEl {
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalEl {
            active: self.active,
            conditional_branch: core::default::Default::default(),
            default_branch: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElRef {
        Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `active` after provisioning.\n"]
    pub fn active(&self) -> PrimExpr<bool> {
        PrimExpr::new(self.shared().clone(), format!("{}.active", self.base))
    }
    #[doc = "Get a reference to the value of field `conditional_branch` after provisioning.\n"]
    pub fn conditional_branch(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElConditionalBranchElRef>
    {
        ListRef::new(
            self.shared().clone(),
            format!("{}.conditional_branch", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `default_branch` after provisioning.\n"]
    pub fn default_branch(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElDefaultBranchElRef>
    {
        ListRef::new(
            self.shared().clone(),
            format!("{}.default_branch", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionEl {
    #[doc = "Set the field `slot_to_elicit`.\n"]
    pub fn set_slot_to_elicit(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.slot_to_elicit = Some(v.into());
        self
    }
    #[doc = "Set the field `suppress_next_message`.\n"]
    pub fn set_suppress_next_message(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.suppress_next_message = Some(v.into());
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionEl {
    type O =
        BlockAssignable<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionEl {
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionEl {
        Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionEl {
            slot_to_elicit: core::default::Default::default(),
            suppress_next_message: core::default::Default::default(),
            type_: self.type_,
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionElRef {
        Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"]
    pub fn slot_to_elicit(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.slot_to_elicit", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"]
    pub fn suppress_next_message(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.suppress_next_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `type_` after provisioning.\n"]
    pub fn type_(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.type", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueEl {
    #[doc = "Set the field `interpreted_value`.\n"]
    pub fn set_interpreted_value(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.interpreted_value = Some(v.into());
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueEl {
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueEl {
        Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueEl {
            interpreted_value: core::default::Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueElRef {
        Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"]
    pub fn interpreted_value(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.interpreted_value", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElDynamic {
    value: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotEl {
    map_block_key: PrimField<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    shape: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    value: Option<
        Vec<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueEl>,
    >,
    dynamic: Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotEl {
    #[doc = "Set the field `shape`.\n"]
    pub fn set_shape(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.shape = Some(v.into());
        self
    }
    #[doc = "Set the field `value`.\n"]
    pub fn set_value(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.value = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.value = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotEl {
    type O =
        BlockAssignable<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotEl {
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotEl {
        Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotEl {
            map_block_key: self.map_block_key,
            shape: core::default::Default::default(),
            value: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElRef {
        Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"]
    pub fn map_block_key(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.map_block_key", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `shape` after provisioning.\n"]
    pub fn shape(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.shape", self.base))
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]
    pub fn value(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotElValueElRef>
    {
        ListRef::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElDynamic {
    slot: Option<
        DynamicBlock<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotEl>,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    name: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    slot: Option<Vec<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentEl {
    #[doc = "Set the field `name`.\n"]
    pub fn set_name(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.name = Some(v.into());
        self
    }
    #[doc = "Set the field `slot`.\n"]
    pub fn set_slot(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElSlotEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.slot = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.slot = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentEl {}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentEl {
        Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentEl {
            name: core::default::Default::default(),
            slot: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElRef {
        Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDynamic {
    dialog_action: Option<
        DynamicBlock<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionEl>,
    >,
    intent:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationNextStepEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    session_attributes: Option<RecField<PrimField<String>>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    dialog_action:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    intent: Option<Vec<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v: impl Into<
            BlockAssignable<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentEl>,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationNextStepEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationNextStepEl {}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationNextStepEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElDeclinationNextStepEl {
        Lexv2modelsIntentConfirmationSettingElDeclinationNextStepEl {
            session_attributes: core::default::Default::default(),
            dialog_action: core::default::Default::default(),
            intent: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElRef {
        Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]
    pub fn dialog_action(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElDialogActionElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]
    pub fn intent(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElIntentElRef> {
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl
    Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageEl
{
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageEl {
    #[doc = "Set the field `custom_payload`.\n"]
    pub fn set_custom_payload(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.custom_payload = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.custom_payload = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `image_response_card`.\n"]
    pub fn set_image_response_card(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.image_response_card = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.image_response_card = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `plain_text_message`.\n"]
    pub fn set_plain_text_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.plain_text_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.plain_text_message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `ssml_message`.\n"]
    pub fn set_ssml_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.ssml_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.ssml_message = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageEl {
        Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageEl {
            custom_payload: core::default::Default::default(),
            image_response_card: core::default::Default::default(),
            plain_text_message: core::default::Default::default(),
            ssml_message: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElRef {
        Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"]    pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElCustomPayloadElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.custom_payload", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"]    pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElImageResponseCardElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.image_response_card", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"]    pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElPlainTextMessageElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.plain_text_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"]    pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElSsmlMessageElRef >{
        ListRef::new(self.shared().clone(), format!("{}.ssml_message", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationEl {
    #[doc = "Set the field `custom_payload`.\n"]
    pub fn set_custom_payload(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.custom_payload = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.custom_payload = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `image_response_card`.\n"]
    pub fn set_image_response_card(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.image_response_card = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.image_response_card = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `plain_text_message`.\n"]
    pub fn set_plain_text_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.plain_text_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.plain_text_message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `ssml_message`.\n"]
    pub fn set_ssml_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.ssml_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.ssml_message = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationEl {
        Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationEl {
            custom_payload: core::default::Default::default(),
            image_response_card: core::default::Default::default(),
            plain_text_message: core::default::Default::default(),
            ssml_message: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElRef {
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElRef
    {
        Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"]    pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElCustomPayloadElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.custom_payload", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"]    pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElImageResponseCardElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.image_response_card", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"]    pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElPlainTextMessageElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.plain_text_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"]    pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElSsmlMessageElRef >{
        ListRef::new(self.shared().clone(), format!("{}.ssml_message", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElDynamic {
    message: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageEl,
        >,
    >,
    variation: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    message: Option<
        Vec<Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageEl>,
    >,
    #[serde(skip_serializing_if = "Option::is_none")]
    variation: Option<
        Vec<Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationEl>,
    >,
    dynamic: Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupEl {
    #[doc = "Set the field `message`.\n"]
    pub fn set_message(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `variation`.\n"]
    pub fn set_variation(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.variation = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.variation = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupEl {
    type O =
        BlockAssignable<Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupEl {}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupEl {
        Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupEl {
            message: core::default::Default::default(),
            variation: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElRef {
        Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `message` after provisioning.\n"]
    pub fn message(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElMessageElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.message", self.base))
    }
    #[doc = "Get a reference to the value of field `variation` after provisioning.\n"]
    pub fn variation(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElVariationElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.variation", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElDynamic {
    message_group: Option<
        DynamicBlock<Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupEl>,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    allow_interrupt: Option<PrimField<bool>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    message_group:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElDeclinationResponseElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElDeclinationResponseEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElDeclinationResponseEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseEl {}
impl BuildLexv2modelsIntentConfirmationSettingElDeclinationResponseEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseEl {
        Lexv2modelsIntentConfirmationSettingElDeclinationResponseEl {
            allow_interrupt: core::default::Default::default(),
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElDeclinationResponseElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElDeclinationResponseElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElDeclinationResponseElRef {
        Lexv2modelsIntentConfirmationSettingElDeclinationResponseElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElDeclinationResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]
    pub fn message_group(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElDeclinationResponseElMessageGroupElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElElicitationCodeHookEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    enable_code_hook_invocation: Option<PrimField<bool>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    invocation_label: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElElicitationCodeHookEl {
    #[doc = "Set the field `enable_code_hook_invocation`.\n"]
    pub fn set_enable_code_hook_invocation(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.enable_code_hook_invocation = Some(v.into());
        self
    }
    #[doc = "Set the field `invocation_label`.\n"]
    pub fn set_invocation_label(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.invocation_label = Some(v.into());
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElElicitationCodeHookEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElElicitationCodeHookEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElElicitationCodeHookEl {}
impl BuildLexv2modelsIntentConfirmationSettingElElicitationCodeHookEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElElicitationCodeHookEl {
        Lexv2modelsIntentConfirmationSettingElElicitationCodeHookEl {
            enable_code_hook_invocation: core::default::Default::default(),
            invocation_label: core::default::Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElElicitationCodeHookElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElElicitationCodeHookElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElElicitationCodeHookElRef {
        Lexv2modelsIntentConfirmationSettingElElicitationCodeHookElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElElicitationCodeHookElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `enable_code_hook_invocation` after provisioning.\n"]
    pub fn enable_code_hook_invocation(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.enable_code_hook_invocation", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `invocation_label` after provisioning.\n"]
    pub fn invocation_label(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.invocation_label", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionEl
{
    expression_string: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionEl {}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionEl
{
    #[doc = ""]
    pub expression_string: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionEl
    {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionEl {
            expression_string: self.expression_string,
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionElRef
    {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionElRef { shared : shared , base : base . to_string () , }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `expression_string` after provisioning.\n"]
    pub fn expression_string(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.expression_string", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElDynamic , }
impl
    Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentEl
{
    #[doc = "Set the field `name`.\n"]
    pub fn set_name(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.name = Some(v.into());
        self
    }
    #[doc = "Set the field `slot`.\n"]
    pub fn set_slot(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.slot = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.slot = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepEl
    {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepEl {
            session_attributes: core::default::Default::default(),
            dialog_action: core::default::Default::default(),
            intent: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElRef
    {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]    pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElIntentElRef >{
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseEl
    {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseEl {
            allow_interrupt: core::default::Default::default(),
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElRef
    {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElDynamic { condition : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionEl >> , next_step : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchEl { name : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] condition : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionEl > > , # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchEl {
    #[doc = "Set the field `condition`.\n"]
    pub fn set_condition(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.condition = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.condition = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `next_step`.\n"]
    pub fn set_next_step(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `response`.\n"]
    pub fn set_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.response = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchEl {
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchEl {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchEl {
            name: self.name,
            condition: core::default::Default::default(),
            next_step: core::default::Default::default(),
            response: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElRef {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
    #[doc = "Get a reference to the value of field `condition` after provisioning.\n"]
    pub fn condition(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElConditionElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.condition", self.base))
    }
    #[doc = "Get a reference to the value of field `next_step` after provisioning.\n"]
    pub fn next_step(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElNextStepElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.next_step", self.base))
    }
    #[doc = "Get a reference to the value of field `response` after provisioning.\n"]
    pub fn response(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElResponseElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.response", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentEl {
    #[doc = "Set the field `name`.\n"]
    pub fn set_name(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.name = Some(v.into());
        self
    }
    #[doc = "Set the field `slot`.\n"]
    pub fn set_slot(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.slot = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.slot = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentEl
{}
impl
    BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentEl
    {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepEl {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepEl {
            session_attributes: core::default::Default::default(),
            dialog_action: core::default::Default::default(),
            intent: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElRef {
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElRef
    {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]    pub fn intent (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElIntentElRef >{
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseEl {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseEl {
            allow_interrupt: core::default::Default::default(),
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElRef {
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElRef
    {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElDynamic {
    next_step: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepEl,
        >,
    >,
    response: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    next_step: Option<
        Vec<Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepEl>,
    >,
    #[serde(skip_serializing_if = "Option::is_none")]
    response: Option<
        Vec<Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseEl>,
    >,
    dynamic: Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchEl {
    #[doc = "Set the field `next_step`.\n"]
    pub fn set_next_step(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `response`.\n"]
    pub fn set_response(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.response = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchEl {
    type O =
        BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchEl {}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchEl {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchEl {
            next_step: core::default::Default::default(),
            response: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElRef {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `next_step` after provisioning.\n"]
    pub fn next_step(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElNextStepElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.next_step", self.base))
    }
    #[doc = "Get a reference to the value of field `response` after provisioning.\n"]
    pub fn response(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElResponseElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.response", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElDynamic {
    conditional_branch: Option<
        DynamicBlock<Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchEl>,
    >,
    default_branch: Option<
        DynamicBlock<Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchEl>,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalEl {
    active: PrimField<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    conditional_branch:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    default_branch:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElFailureConditionalElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalEl {
    #[doc = "Set the field `conditional_branch`.\n"]
    pub fn set_conditional_branch(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.conditional_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.conditional_branch = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `default_branch`.\n"]
    pub fn set_default_branch(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.default_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.default_branch = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureConditionalEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureConditionalEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureConditionalEl {
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureConditionalEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalEl {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalEl {
            active: self.active,
            conditional_branch: core::default::Default::default(),
            default_branch: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureConditionalElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureConditionalElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureConditionalElRef {
        Lexv2modelsIntentConfirmationSettingElFailureConditionalElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureConditionalElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `active` after provisioning.\n"]
    pub fn active(&self) -> PrimExpr<bool> {
        PrimExpr::new(self.shared().clone(), format!("{}.active", self.base))
    }
    #[doc = "Get a reference to the value of field `conditional_branch` after provisioning.\n"]
    pub fn conditional_branch(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElFailureConditionalElConditionalBranchElRef>
    {
        ListRef::new(
            self.shared().clone(),
            format!("{}.conditional_branch", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `default_branch` after provisioning.\n"]
    pub fn default_branch(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElFailureConditionalElDefaultBranchElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.default_branch", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionEl {
    #[doc = "Set the field `slot_to_elicit`.\n"]
    pub fn set_slot_to_elicit(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.slot_to_elicit = Some(v.into());
        self
    }
    #[doc = "Set the field `suppress_next_message`.\n"]
    pub fn set_suppress_next_message(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.suppress_next_message = Some(v.into());
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionEl {
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionEl {
        Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionEl {
            slot_to_elicit: core::default::Default::default(),
            suppress_next_message: core::default::Default::default(),
            type_: self.type_,
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionElRef {
        Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"]
    pub fn slot_to_elicit(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.slot_to_elicit", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"]
    pub fn suppress_next_message(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.suppress_next_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `type_` after provisioning.\n"]
    pub fn type_(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.type", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueEl {
    #[doc = "Set the field `interpreted_value`.\n"]
    pub fn set_interpreted_value(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.interpreted_value = Some(v.into());
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueEl {}
impl BuildLexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueEl {
        Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueEl {
            interpreted_value: core::default::Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueElRef {
        Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"]
    pub fn interpreted_value(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.interpreted_value", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElDynamic {
    value: Option<
        DynamicBlock<Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueEl>,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotEl {
    map_block_key: PrimField<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    shape: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    value:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotEl {
    #[doc = "Set the field `shape`.\n"]
    pub fn set_shape(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.shape = Some(v.into());
        self
    }
    #[doc = "Set the field `value`.\n"]
    pub fn set_value(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.value = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.value = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotEl {
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotEl {
        Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotEl {
            map_block_key: self.map_block_key,
            shape: core::default::Default::default(),
            value: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElRef {
        Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"]
    pub fn map_block_key(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.map_block_key", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `shape` after provisioning.\n"]
    pub fn shape(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.shape", self.base))
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]
    pub fn value(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotElValueElRef>
    {
        ListRef::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElDynamic {
    slot:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    name: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    slot: Option<Vec<Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentEl {
    #[doc = "Set the field `name`.\n"]
    pub fn set_name(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.name = Some(v.into());
        self
    }
    #[doc = "Set the field `slot`.\n"]
    pub fn set_slot(
        mut self,
        v: impl Into<
            BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElSlotEl>,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.slot = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.slot = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureNextStepElIntentEl {}
impl BuildLexv2modelsIntentConfirmationSettingElFailureNextStepElIntentEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentEl {
        Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentEl {
            name: core::default::Default::default(),
            slot: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElRef {
        Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureNextStepElDynamic {
    dialog_action:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionEl>>,
    intent: Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureNextStepEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    session_attributes: Option<RecField<PrimField<String>>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    dialog_action:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    intent: Option<Vec<Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElFailureNextStepElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElFailureNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v: impl Into<
            BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionEl>,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureNextStepEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureNextStepEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureNextStepEl {}
impl BuildLexv2modelsIntentConfirmationSettingElFailureNextStepEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElFailureNextStepEl {
        Lexv2modelsIntentConfirmationSettingElFailureNextStepEl {
            session_attributes: core::default::Default::default(),
            dialog_action: core::default::Default::default(),
            intent: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureNextStepElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureNextStepElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureNextStepElRef {
        Lexv2modelsIntentConfirmationSettingElFailureNextStepElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureNextStepElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]
    pub fn dialog_action(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElFailureNextStepElDialogActionElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]
    pub fn intent(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElFailureNextStepElIntentElRef> {
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadEl {}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]
    pub fn value(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl
    Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageEl
{
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageEl {}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl
    BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageEl
    {
        Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]
    pub fn value(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageEl {
    #[doc = "Set the field `custom_payload`.\n"]
    pub fn set_custom_payload(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.custom_payload = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.custom_payload = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `image_response_card`.\n"]
    pub fn set_image_response_card(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.image_response_card = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.image_response_card = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `plain_text_message`.\n"]
    pub fn set_plain_text_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.plain_text_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.plain_text_message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `ssml_message`.\n"]
    pub fn set_ssml_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.ssml_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.ssml_message = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageEl {}
impl BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageEl {
        Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageEl {
            custom_payload: core::default::Default::default(),
            image_response_card: core::default::Default::default(),
            plain_text_message: core::default::Default::default(),
            ssml_message: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElRef {
        Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"]    pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElCustomPayloadElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.custom_payload", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"]    pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElImageResponseCardElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.image_response_card", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"]    pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.plain_text_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"]    pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElSsmlMessageElRef >{
        ListRef::new(self.shared().clone(), format!("{}.ssml_message", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl
    Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadEl
{
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageEl {}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]
    pub fn value(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationEl {
    #[doc = "Set the field `custom_payload`.\n"]
    pub fn set_custom_payload(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.custom_payload = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.custom_payload = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `image_response_card`.\n"]
    pub fn set_image_response_card(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.image_response_card = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.image_response_card = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `plain_text_message`.\n"]
    pub fn set_plain_text_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.plain_text_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.plain_text_message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `ssml_message`.\n"]
    pub fn set_ssml_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.ssml_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.ssml_message = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationEl {
}
impl BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationEl {
        Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationEl {
            custom_payload: core::default::Default::default(),
            image_response_card: core::default::Default::default(),
            plain_text_message: core::default::Default::default(),
            ssml_message: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElRef {
        Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"]    pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElCustomPayloadElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.custom_payload", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"]    pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElImageResponseCardElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.image_response_card", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"]    pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.plain_text_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"]    pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElSsmlMessageElRef >{
        ListRef::new(self.shared().clone(), format!("{}.ssml_message", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElDynamic {
    message: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageEl,
        >,
    >,
    variation: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    message:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    variation: Option<
        Vec<Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationEl>,
    >,
    dynamic: Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupEl {
    #[doc = "Set the field `message`.\n"]
    pub fn set_message(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `variation`.\n"]
    pub fn set_variation(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.variation = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.variation = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupEl {}
impl BuildLexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupEl {
        Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupEl {
            message: core::default::Default::default(),
            variation: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElRef {
        Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `message` after provisioning.\n"]
    pub fn message(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElMessageElRef>
    {
        ListRef::new(self.shared().clone(), format!("{}.message", self.base))
    }
    #[doc = "Get a reference to the value of field `variation` after provisioning.\n"]
    pub fn variation(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElVariationElRef>
    {
        ListRef::new(self.shared().clone(), format!("{}.variation", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElFailureResponseElDynamic {
    message_group:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    allow_interrupt: Option<PrimField<bool>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    message_group:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElFailureResponseElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElFailureResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v: impl Into<
            BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupEl>,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElFailureResponseEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureResponseEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElFailureResponseEl {}
impl BuildLexv2modelsIntentConfirmationSettingElFailureResponseEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElFailureResponseEl {
        Lexv2modelsIntentConfirmationSettingElFailureResponseEl {
            allow_interrupt: core::default::Default::default(),
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElFailureResponseElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElFailureResponseElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElFailureResponseElRef {
        Lexv2modelsIntentConfirmationSettingElFailureResponseElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElFailureResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]
    pub fn message_group(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElFailureResponseElMessageGroupElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl
    Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageEl
{
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageEl {
    #[doc = "Set the field `custom_payload`.\n"]
    pub fn set_custom_payload(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.custom_payload = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.custom_payload = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `image_response_card`.\n"]
    pub fn set_image_response_card(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.image_response_card = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.image_response_card = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `plain_text_message`.\n"]
    pub fn set_plain_text_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.plain_text_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.plain_text_message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `ssml_message`.\n"]
    pub fn set_ssml_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.ssml_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.ssml_message = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageEl {
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageEl {
            custom_payload: core::default::Default::default(),
            image_response_card: core::default::Default::default(),
            plain_text_message: core::default::Default::default(),
            ssml_message: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElRef {
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"]    pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElCustomPayloadElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.custom_payload", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"]    pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElImageResponseCardElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.image_response_card", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"]    pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElPlainTextMessageElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.plain_text_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"]    pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElSsmlMessageElRef >{
        ListRef::new(self.shared().clone(), format!("{}.ssml_message", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationEl {
    #[doc = "Set the field `custom_payload`.\n"]
    pub fn set_custom_payload(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.custom_payload = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.custom_payload = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `image_response_card`.\n"]
    pub fn set_image_response_card(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.image_response_card = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.image_response_card = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `plain_text_message`.\n"]
    pub fn set_plain_text_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.plain_text_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.plain_text_message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `ssml_message`.\n"]
    pub fn set_ssml_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.ssml_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.ssml_message = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationEl {
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationEl {
            custom_payload: core::default::Default::default(),
            image_response_card: core::default::Default::default(),
            plain_text_message: core::default::Default::default(),
            ssml_message: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElRef {
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElRef
    {
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"]    pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElCustomPayloadElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.custom_payload", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"]    pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElImageResponseCardElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.image_response_card", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"]    pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElPlainTextMessageElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.plain_text_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"]    pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElSsmlMessageElRef >{
        ListRef::new(self.shared().clone(), format!("{}.ssml_message", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElDynamic {
    message: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageEl,
        >,
    >,
    variation: Option<
        DynamicBlock<
            Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    message: Option<
        Vec<Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageEl>,
    >,
    #[serde(skip_serializing_if = "Option::is_none")]
    variation: Option<
        Vec<Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationEl>,
    >,
    dynamic: Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupEl {
    #[doc = "Set the field `message`.\n"]
    pub fn set_message(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `variation`.\n"]
    pub fn set_variation(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.variation = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.variation = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupEl {
    type O =
        BlockAssignable<Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupEl {}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupEl {
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupEl {
            message: core::default::Default::default(),
            variation: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElRef {
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `message` after provisioning.\n"]
    pub fn message(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElMessageElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.message", self.base))
    }
    #[doc = "Get a reference to the value of field `variation` after provisioning.\n"]
    pub fn variation(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElVariationElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.variation", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesEl
{
    allow_audio_input: PrimField<bool>,
    allow_dtmf_input: PrimField<bool>,
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesEl
{
    #[doc = ""]
    pub allow_audio_input: PrimField<bool>,
    #[doc = ""]
    pub allow_dtmf_input: PrimField<bool>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesEl { allow_audio_input : self . allow_audio_input , allow_dtmf_input : self . allow_dtmf_input , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_audio_input` after provisioning.\n"] pub fn allow_audio_input (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_audio_input" , self . base)) } # [doc = "Get a reference to the value of field `allow_dtmf_input` after provisioning.\n"] pub fn allow_dtmf_input (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_dtmf_input" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationEl
{
    end_timeout_ms: PrimField<f64>,
    max_length_ms: PrimField<f64>,
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationEl
{
    #[doc = ""]
    pub end_timeout_ms: PrimField<f64>,
    #[doc = ""]
    pub max_length_ms: PrimField<f64>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationEl { end_timeout_ms : self . end_timeout_ms , max_length_ms : self . max_length_ms , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `end_timeout_ms` after provisioning.\n"] pub fn end_timeout_ms (& self) -> PrimExpr < f64 > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.end_timeout_ms" , self . base)) } # [doc = "Get a reference to the value of field `max_length_ms` after provisioning.\n"] pub fn max_length_ms (& self) -> PrimExpr < f64 > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.max_length_ms" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationEl
{
    deletion_character: PrimField<String>,
    end_character: PrimField<String>,
    end_timeout_ms: PrimField<f64>,
    max_length: PrimField<f64>,
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationEl
{
    #[doc = ""]
    pub deletion_character: PrimField<String>,
    #[doc = ""]
    pub end_character: PrimField<String>,
    #[doc = ""]
    pub end_timeout_ms: PrimField<f64>,
    #[doc = ""]
    pub max_length: PrimField<f64>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationEl { deletion_character : self . deletion_character , end_character : self . end_character , end_timeout_ms : self . end_timeout_ms , max_length : self . max_length , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `deletion_character` after provisioning.\n"] pub fn deletion_character (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.deletion_character" , self . base)) } # [doc = "Get a reference to the value of field `end_character` after provisioning.\n"] pub fn end_character (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.end_character" , self . base)) } # [doc = "Get a reference to the value of field `end_timeout_ms` after provisioning.\n"] pub fn end_timeout_ms (& self) -> PrimExpr < f64 > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.end_timeout_ms" , self . base)) } # [doc = "Get a reference to the value of field `max_length` after provisioning.\n"] pub fn max_length (& self) -> PrimExpr < f64 > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.max_length" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDynamic { audio_specification : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationEl >> , dtmf_specification : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationEl { start_timeout_ms : PrimField < f64 > , # [serde (skip_serializing_if = "Option::is_none")] audio_specification : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationEl > > , # [serde (skip_serializing_if = "Option::is_none")] dtmf_specification : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationEl { # [doc = "Set the field `audio_specification`.\n"] pub fn set_audio_specification (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . audio_specification = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . audio_specification = Some (d) ; } } self } # [doc = "Set the field `dtmf_specification`.\n"] pub fn set_dtmf_specification (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dtmf_specification = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dtmf_specification = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationEl
{
    #[doc = ""]
    pub start_timeout_ms: PrimField<f64>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationEl { start_timeout_ms : self . start_timeout_ms , audio_specification : core :: default :: Default :: default () , dtmf_specification : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `start_timeout_ms` after provisioning.\n"] pub fn start_timeout_ms (& self) -> PrimExpr < f64 > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.start_timeout_ms" , self . base)) } # [doc = "Get a reference to the value of field `audio_specification` after provisioning.\n"] pub fn audio_specification (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElAudioSpecificationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.audio_specification" , self . base)) } # [doc = "Get a reference to the value of field `dtmf_specification` after provisioning.\n"] pub fn dtmf_specification (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElDtmfSpecificationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dtmf_specification" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationEl
{
    start_timeout_ms: PrimField<f64>,
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationEl { }
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationEl { type O = BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationEl
{
    #[doc = ""]
    pub start_timeout_ms: PrimField<f64>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationEl { pub fn build (self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationEl { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationEl { start_timeout_ms : self . start_timeout_ms , } } }
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationElRef { Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `start_timeout_ms` after provisioning.\n"] pub fn start_timeout_ms (& self) -> PrimExpr < f64 > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.start_timeout_ms" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElDynamic { allowed_input_types : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesEl >> , audio_and_dtmf_input_specification : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationEl >> , text_input_specification : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] allowed_input_types : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesEl > > , # [serde (skip_serializing_if = "Option::is_none")] audio_and_dtmf_input_specification : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationEl > > , # [serde (skip_serializing_if = "Option::is_none")] text_input_specification : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `allowed_input_types`.\n"]
    pub fn set_allowed_input_types(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.allowed_input_types = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.allowed_input_types = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `audio_and_dtmf_input_specification`.\n"]
    pub fn set_audio_and_dtmf_input_specification(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.audio_and_dtmf_input_specification = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.audio_and_dtmf_input_specification = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `text_input_specification`.\n"]
    pub fn set_text_input_specification(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.text_input_specification = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.text_input_specification = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationEl
    {
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationEl {
            allow_interrupt: core::default::Default::default(),
            map_block_key: self.map_block_key,
            allowed_input_types: core::default::Default::default(),
            audio_and_dtmf_input_specification: core::default::Default::default(),
            text_input_specification: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElRef
    {
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElRef { shared : shared , base : base . to_string () , }
    }
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"]
    pub fn map_block_key(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.map_block_key", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `allowed_input_types` after provisioning.\n"]    pub fn allowed_input_types (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAllowedInputTypesElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.allowed_input_types", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `audio_and_dtmf_input_specification` after provisioning.\n"]    pub fn audio_and_dtmf_input_specification (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElAudioAndDtmfInputSpecificationElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.audio_and_dtmf_input_specification", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `text_input_specification` after provisioning.\n"]    pub fn text_input_specification (& self) -> ListRef < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationElTextInputSpecificationElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.text_input_specification", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupEl >> , prompt_attempts_specification : Option < DynamicBlock < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , max_retries : PrimField < f64 > , # [serde (skip_serializing_if = "Option::is_none")] message_selection_strategy : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupEl > > , # [serde (skip_serializing_if = "Option::is_none")] prompt_attempts_specification : Option < Vec < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationEl > > , dynamic : Lexv2modelsIntentConfirmationSettingElPromptSpecificationElDynamic , }
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_selection_strategy`.\n"]
    pub fn set_message_selection_strategy(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.message_selection_strategy = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `prompt_attempts_specification`.\n"]
    pub fn set_prompt_attempts_specification(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentConfirmationSettingElPromptSpecificationElPromptAttemptsSpecificationEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.prompt_attempts_specification = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.prompt_attempts_specification = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingElPromptSpecificationEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingElPromptSpecificationEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationEl {
    #[doc = ""]
    pub max_retries: PrimField<f64>,
}
impl BuildLexv2modelsIntentConfirmationSettingElPromptSpecificationEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationEl {
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationEl {
            allow_interrupt: core::default::Default::default(),
            max_retries: self.max_retries,
            message_selection_strategy: core::default::Default::default(),
            message_group: core::default::Default::default(),
            prompt_attempts_specification: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElPromptSpecificationElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElPromptSpecificationElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentConfirmationSettingElPromptSpecificationElRef {
        Lexv2modelsIntentConfirmationSettingElPromptSpecificationElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElPromptSpecificationElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `max_retries` after provisioning.\n"]
    pub fn max_retries(&self) -> PrimExpr<f64> {
        PrimExpr::new(self.shared().clone(), format!("{}.max_retries", self.base))
    }
    #[doc = "Get a reference to the value of field `message_selection_strategy` after provisioning.\n"]
    pub fn message_selection_strategy(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.message_selection_strategy", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]
    pub fn message_group(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElPromptSpecificationElMessageGroupElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentConfirmationSettingElDynamic {
    code_hook: Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElCodeHookEl>>,
    confirmation_conditional:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElConfirmationConditionalEl>>,
    confirmation_next_step:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepEl>>,
    confirmation_response:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElConfirmationResponseEl>>,
    declination_conditional:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElDeclinationConditionalEl>>,
    declination_next_step:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepEl>>,
    declination_response:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElDeclinationResponseEl>>,
    elicitation_code_hook:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElElicitationCodeHookEl>>,
    failure_conditional:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElFailureConditionalEl>>,
    failure_next_step:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElFailureNextStepEl>>,
    failure_response: Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElFailureResponseEl>>,
    prompt_specification:
        Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingElPromptSpecificationEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentConfirmationSettingEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    active: Option<PrimField<bool>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    code_hook: Option<Vec<Lexv2modelsIntentConfirmationSettingElCodeHookEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    confirmation_conditional:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElConfirmationConditionalEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    confirmation_next_step:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    confirmation_response:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElConfirmationResponseEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    declination_conditional:
        Option<Vec<Lexv2modelsIntentConfirmationSettingElDeclinationConditionalEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    declination_next_step: Option<Vec<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    declination_response: Option<Vec<Lexv2modelsIntentConfirmationSettingElDeclinationResponseEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    elicitation_code_hook: Option<Vec<Lexv2modelsIntentConfirmationSettingElElicitationCodeHookEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    failure_conditional: Option<Vec<Lexv2modelsIntentConfirmationSettingElFailureConditionalEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    failure_next_step: Option<Vec<Lexv2modelsIntentConfirmationSettingElFailureNextStepEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    failure_response: Option<Vec<Lexv2modelsIntentConfirmationSettingElFailureResponseEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    prompt_specification: Option<Vec<Lexv2modelsIntentConfirmationSettingElPromptSpecificationEl>>,
    dynamic: Lexv2modelsIntentConfirmationSettingElDynamic,
}
impl Lexv2modelsIntentConfirmationSettingEl {
    #[doc = "Set the field `active`.\n"]
    pub fn set_active(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.active = Some(v.into());
        self
    }
    #[doc = "Set the field `code_hook`.\n"]
    pub fn set_code_hook(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentConfirmationSettingElCodeHookEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.code_hook = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.code_hook = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `confirmation_conditional`.\n"]
    pub fn set_confirmation_conditional(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentConfirmationSettingElConfirmationConditionalEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.confirmation_conditional = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.confirmation_conditional = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `confirmation_next_step`.\n"]
    pub fn set_confirmation_next_step(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.confirmation_next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.confirmation_next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `confirmation_response`.\n"]
    pub fn set_confirmation_response(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentConfirmationSettingElConfirmationResponseEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.confirmation_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.confirmation_response = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `declination_conditional`.\n"]
    pub fn set_declination_conditional(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentConfirmationSettingElDeclinationConditionalEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.declination_conditional = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.declination_conditional = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `declination_next_step`.\n"]
    pub fn set_declination_next_step(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.declination_next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.declination_next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `declination_response`.\n"]
    pub fn set_declination_response(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentConfirmationSettingElDeclinationResponseEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.declination_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.declination_response = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `elicitation_code_hook`.\n"]
    pub fn set_elicitation_code_hook(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentConfirmationSettingElElicitationCodeHookEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.elicitation_code_hook = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.elicitation_code_hook = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `failure_conditional`.\n"]
    pub fn set_failure_conditional(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureConditionalEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.failure_conditional = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.failure_conditional = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `failure_next_step`.\n"]
    pub fn set_failure_next_step(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureNextStepEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.failure_next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.failure_next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `failure_response`.\n"]
    pub fn set_failure_response(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentConfirmationSettingElFailureResponseEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.failure_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.failure_response = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `prompt_specification`.\n"]
    pub fn set_prompt_specification(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentConfirmationSettingElPromptSpecificationEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.prompt_specification = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.prompt_specification = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentConfirmationSettingEl {
    type O = BlockAssignable<Lexv2modelsIntentConfirmationSettingEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentConfirmationSettingEl {}
impl BuildLexv2modelsIntentConfirmationSettingEl {
    pub fn build(self) -> Lexv2modelsIntentConfirmationSettingEl {
        Lexv2modelsIntentConfirmationSettingEl {
            active: core::default::Default::default(),
            code_hook: core::default::Default::default(),
            confirmation_conditional: core::default::Default::default(),
            confirmation_next_step: core::default::Default::default(),
            confirmation_response: core::default::Default::default(),
            declination_conditional: core::default::Default::default(),
            declination_next_step: core::default::Default::default(),
            declination_response: core::default::Default::default(),
            elicitation_code_hook: core::default::Default::default(),
            failure_conditional: core::default::Default::default(),
            failure_next_step: core::default::Default::default(),
            failure_response: core::default::Default::default(),
            prompt_specification: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentConfirmationSettingElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentConfirmationSettingElRef {
    fn new(shared: StackShared, base: String) -> Lexv2modelsIntentConfirmationSettingElRef {
        Lexv2modelsIntentConfirmationSettingElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentConfirmationSettingElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `active` after provisioning.\n"]
    pub fn active(&self) -> PrimExpr<bool> {
        PrimExpr::new(self.shared().clone(), format!("{}.active", self.base))
    }
    #[doc = "Get a reference to the value of field `code_hook` after provisioning.\n"]
    pub fn code_hook(&self) -> ListRef<Lexv2modelsIntentConfirmationSettingElCodeHookElRef> {
        ListRef::new(self.shared().clone(), format!("{}.code_hook", self.base))
    }
    #[doc = "Get a reference to the value of field `confirmation_conditional` after provisioning.\n"]
    pub fn confirmation_conditional(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElConfirmationConditionalElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.confirmation_conditional", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `confirmation_next_step` after provisioning.\n"]
    pub fn confirmation_next_step(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElConfirmationNextStepElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.confirmation_next_step", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `confirmation_response` after provisioning.\n"]
    pub fn confirmation_response(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElConfirmationResponseElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.confirmation_response", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `declination_conditional` after provisioning.\n"]
    pub fn declination_conditional(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElDeclinationConditionalElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.declination_conditional", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `declination_next_step` after provisioning.\n"]
    pub fn declination_next_step(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElDeclinationNextStepElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.declination_next_step", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `declination_response` after provisioning.\n"]
    pub fn declination_response(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElDeclinationResponseElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.declination_response", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `elicitation_code_hook` after provisioning.\n"]
    pub fn elicitation_code_hook(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElElicitationCodeHookElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.elicitation_code_hook", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `failure_conditional` after provisioning.\n"]
    pub fn failure_conditional(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElFailureConditionalElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.failure_conditional", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `failure_next_step` after provisioning.\n"]
    pub fn failure_next_step(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElFailureNextStepElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.failure_next_step", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `failure_response` after provisioning.\n"]
    pub fn failure_response(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElFailureResponseElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.failure_response", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `prompt_specification` after provisioning.\n"]
    pub fn prompt_specification(
        &self,
    ) -> ListRef<Lexv2modelsIntentConfirmationSettingElPromptSpecificationElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.prompt_specification", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentDialogCodeHookEl {
    enabled: PrimField<bool>,
}
impl Lexv2modelsIntentDialogCodeHookEl {}
impl ToListMappable for Lexv2modelsIntentDialogCodeHookEl {
    type O = BlockAssignable<Lexv2modelsIntentDialogCodeHookEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentDialogCodeHookEl {
    #[doc = ""]
    pub enabled: PrimField<bool>,
}
impl BuildLexv2modelsIntentDialogCodeHookEl {
    pub fn build(self) -> Lexv2modelsIntentDialogCodeHookEl {
        Lexv2modelsIntentDialogCodeHookEl {
            enabled: self.enabled,
        }
    }
}
pub struct Lexv2modelsIntentDialogCodeHookElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentDialogCodeHookElRef {
    fn new(shared: StackShared, base: String) -> Lexv2modelsIntentDialogCodeHookElRef {
        Lexv2modelsIntentDialogCodeHookElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentDialogCodeHookElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `enabled` after provisioning.\n"]
    pub fn enabled(&self) -> PrimExpr<bool> {
        PrimExpr::new(self.shared().clone(), format!("{}.enabled", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] delay_in_seconds : Option < PrimField < f64 > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `delay_in_seconds`.\n"]
    pub fn set_delay_in_seconds(mut self, v: impl Into<PrimField<f64>>) -> Self {
        self.delay_in_seconds = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseEl
    {
        Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseEl {
            allow_interrupt: core::default::Default::default(),
            delay_in_seconds: core::default::Default::default(),
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElRef
    {
        Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `delay_in_seconds` after provisioning.\n"]
    pub fn delay_in_seconds(&self) -> PrimExpr<f64> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.delay_in_seconds", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupEl { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElRef { Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , frequency_in_seconds : PrimField < f64 > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseEl
{
    #[doc = ""]
    pub frequency_in_seconds: PrimField<f64>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseEl
    {
        Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseEl {
            allow_interrupt: core::default::Default::default(),
            frequency_in_seconds: self.frequency_in_seconds,
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElRef
    {
        Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `frequency_in_seconds` after provisioning.\n"]
    pub fn frequency_in_seconds(&self) -> PrimExpr<f64> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.frequency_in_seconds", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElDynamic {
    start_response: Option<
        DynamicBlock<
            Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseEl,
        >,
    >,
    update_response: Option<
        DynamicBlock<
            Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationEl {
    active: PrimField<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    timeout_in_seconds: Option<PrimField<f64>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    start_response: Option<
        Vec<Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseEl>,
    >,
    #[serde(skip_serializing_if = "Option::is_none")]
    update_response: Option<
        Vec<
            Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseEl,
        >,
    >,
    dynamic: Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElDynamic,
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationEl {
    #[doc = "Set the field `timeout_in_seconds`.\n"]
    pub fn set_timeout_in_seconds(mut self, v: impl Into<PrimField<f64>>) -> Self {
        self.timeout_in_seconds = Some(v.into());
        self
    }
    #[doc = "Set the field `start_response`.\n"]
    pub fn set_start_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.start_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.start_response = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `update_response`.\n"]
    pub fn set_update_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.update_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.update_response = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationEl {
    type O =
        BlockAssignable<Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationEl {
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationEl {
    pub fn build(self) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationEl {
        Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationEl {
            active: self.active,
            timeout_in_seconds: core::default::Default::default(),
            start_response: core::default::Default::default(),
            update_response: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElRef {
        Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `active` after provisioning.\n"]
    pub fn active(&self) -> PrimExpr<bool> {
        PrimExpr::new(self.shared().clone(), format!("{}.active", self.base))
    }
    #[doc = "Get a reference to the value of field `timeout_in_seconds` after provisioning.\n"]
    pub fn timeout_in_seconds(&self) -> PrimExpr<f64> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.timeout_in_seconds", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `start_response` after provisioning.\n"]
    pub fn start_response(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElStartResponseElRef,
    > {
        ListRef::new(
            self.shared().clone(),
            format!("{}.start_response", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `update_response` after provisioning.\n"]
    pub fn update_response(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElUpdateResponseElRef,
    > {
        ListRef::new(
            self.shared().clone(),
            format!("{}.update_response", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionEl
{
    expression_string: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionEl
{
    #[doc = ""]
    pub expression_string: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionEl { expression_string : self . expression_string , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `expression_string` after provisioning.\n"] pub fn expression_string (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.expression_string" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElDynamic { condition : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionEl >> , next_step : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchEl { name : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] condition : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionEl > > , # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchEl { # [doc = "Set the field `condition`.\n"] pub fn set_condition (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . condition = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . condition = Some (d) ; } } self } # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchEl
{
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchEl { name : self . name , condition : core :: default :: Default :: default () , next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } # [doc = "Get a reference to the value of field `condition` after provisioning.\n"] pub fn condition (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElConditionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.condition" , self . base)) } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElDynamic { next_step : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchEl { # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchEl { # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchEl { next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDynamic { conditional_branch : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchEl >> , default_branch : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalEl { active : PrimField < bool > , # [serde (skip_serializing_if = "Option::is_none")] conditional_branch : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchEl > > , # [serde (skip_serializing_if = "Option::is_none")] default_branch : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDynamic , }
impl
    Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalEl
{
    #[doc = "Set the field `conditional_branch`.\n"]
    pub fn set_conditional_branch(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.conditional_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.conditional_branch = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `default_branch`.\n"]
    pub fn set_default_branch(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.default_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.default_branch = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalEl
{
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalEl { active : self . active , conditional_branch : core :: default :: Default :: default () , default_branch : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `active` after provisioning.\n"] pub fn active (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.active" , self . base)) } # [doc = "Get a reference to the value of field `conditional_branch` after provisioning.\n"] pub fn conditional_branch (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElConditionalBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.conditional_branch" , self . base)) } # [doc = "Get a reference to the value of field `default_branch` after provisioning.\n"] pub fn default_branch (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElDefaultBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.default_branch" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepEl
{}
impl
    BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepEl
    {
        Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , }
    }
}
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]    pub fn intent (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElIntentElRef >{
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseEl
{}
impl
    BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseEl
    {
        Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , }
    }
}
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionEl
{
    expression_string: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionEl
{
    #[doc = ""]
    pub expression_string: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionEl { expression_string : self . expression_string , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `expression_string` after provisioning.\n"] pub fn expression_string (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.expression_string" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElDynamic { condition : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionEl >> , next_step : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchEl { name : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] condition : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionEl > > , # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchEl { # [doc = "Set the field `condition`.\n"] pub fn set_condition (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . condition = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . condition = Some (d) ; } } self } # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchEl
{
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchEl { name : self . name , condition : core :: default :: Default :: default () , next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } # [doc = "Get a reference to the value of field `condition` after provisioning.\n"] pub fn condition (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElConditionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.condition" , self . base)) } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElDynamic { next_step : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchEl { # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchEl { # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchEl { next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDynamic { conditional_branch : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchEl >> , default_branch : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalEl { active : PrimField < bool > , # [serde (skip_serializing_if = "Option::is_none")] conditional_branch : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchEl > > , # [serde (skip_serializing_if = "Option::is_none")] default_branch : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDynamic , }
impl
    Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalEl
{
    #[doc = "Set the field `conditional_branch`.\n"]
    pub fn set_conditional_branch(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.conditional_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.conditional_branch = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `default_branch`.\n"]
    pub fn set_default_branch(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.default_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.default_branch = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalEl
{
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalEl { active : self . active , conditional_branch : core :: default :: Default :: default () , default_branch : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `active` after provisioning.\n"] pub fn active (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.active" , self . base)) } # [doc = "Get a reference to the value of field `conditional_branch` after provisioning.\n"] pub fn conditional_branch (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElConditionalBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.conditional_branch" , self . base)) } # [doc = "Get a reference to the value of field `default_branch` after provisioning.\n"] pub fn default_branch (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElDefaultBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.default_branch" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepEl
{}
impl
    BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepEl
    {
        Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , }
    }
}
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]    pub fn intent (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElIntentElRef >{
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseEl
{}
impl
    BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseEl
    {
        Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , }
    }
}
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionEl
{
    expression_string: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionEl
{
    #[doc = ""]
    pub expression_string: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { expression_string : self . expression_string , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `expression_string` after provisioning.\n"] pub fn expression_string (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.expression_string" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElDynamic { condition : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionEl >> , next_step : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchEl { name : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] condition : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionEl > > , # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchEl { # [doc = "Set the field `condition`.\n"] pub fn set_condition (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . condition = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . condition = Some (d) ; } } self } # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchEl
{
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchEl { name : self . name , condition : core :: default :: Default :: default () , next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } # [doc = "Get a reference to the value of field `condition` after provisioning.\n"] pub fn condition (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.condition" , self . base)) } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElDynamic { next_step : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchEl { # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchEl { # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchEl { next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDynamic { conditional_branch : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchEl >> , default_branch : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalEl { active : PrimField < bool > , # [serde (skip_serializing_if = "Option::is_none")] conditional_branch : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchEl > > , # [serde (skip_serializing_if = "Option::is_none")] default_branch : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDynamic , }
impl
    Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalEl
{
    #[doc = "Set the field `conditional_branch`.\n"]
    pub fn set_conditional_branch(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.conditional_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.conditional_branch = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `default_branch`.\n"]
    pub fn set_default_branch(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.default_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.default_branch = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalEl
{
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalEl { active : self . active , conditional_branch : core :: default :: Default :: default () , default_branch : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `active` after provisioning.\n"] pub fn active (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.active" , self . base)) } # [doc = "Get a reference to the value of field `conditional_branch` after provisioning.\n"] pub fn conditional_branch (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElConditionalBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.conditional_branch" , self . base)) } # [doc = "Get a reference to the value of field `default_branch` after provisioning.\n"] pub fn default_branch (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElDefaultBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.default_branch" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepEl
{}
impl
    BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepEl
    {
        Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , }
    }
}
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]    pub fn intent (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElIntentElRef >{
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupEl { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseEl
{}
impl
    BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseEl
    {
        Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , }
    }
}
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElRef { Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElDynamic { failure_conditional : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalEl >> , failure_next_step : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepEl >> , failure_response : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseEl >> , success_conditional : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalEl >> , success_next_step : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepEl >> , success_response : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseEl >> , timeout_conditional : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalEl >> , timeout_next_step : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepEl >> , timeout_response : Option < DynamicBlock < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationEl { # [serde (skip_serializing_if = "Option::is_none")] failure_conditional : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalEl > > , # [serde (skip_serializing_if = "Option::is_none")] failure_next_step : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] failure_response : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseEl > > , # [serde (skip_serializing_if = "Option::is_none")] success_conditional : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalEl > > , # [serde (skip_serializing_if = "Option::is_none")] success_next_step : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] success_response : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseEl > > , # [serde (skip_serializing_if = "Option::is_none")] timeout_conditional : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalEl > > , # [serde (skip_serializing_if = "Option::is_none")] timeout_next_step : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] timeout_response : Option < Vec < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseEl > > , dynamic : Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElDynamic , }
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationEl {
    #[doc = "Set the field `failure_conditional`.\n"]
    pub fn set_failure_conditional(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.failure_conditional = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.failure_conditional = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `failure_next_step`.\n"]
    pub fn set_failure_next_step(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.failure_next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.failure_next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `failure_response`.\n"]
    pub fn set_failure_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.failure_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.failure_response = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `success_conditional`.\n"]
    pub fn set_success_conditional(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.success_conditional = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.success_conditional = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `success_next_step`.\n"]
    pub fn set_success_next_step(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.success_next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.success_next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `success_response`.\n"]
    pub fn set_success_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.success_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.success_response = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `timeout_conditional`.\n"]
    pub fn set_timeout_conditional(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.timeout_conditional = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.timeout_conditional = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `timeout_next_step`.\n"]
    pub fn set_timeout_next_step(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.timeout_next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.timeout_next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `timeout_response`.\n"]
    pub fn set_timeout_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.timeout_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.timeout_response = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationEl {
    type O =
        BlockAssignable<Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationEl {}
impl BuildLexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationEl {
        Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationEl {
            failure_conditional: core::default::Default::default(),
            failure_next_step: core::default::Default::default(),
            failure_response: core::default::Default::default(),
            success_conditional: core::default::Default::default(),
            success_next_step: core::default::Default::default(),
            success_response: core::default::Default::default(),
            timeout_conditional: core::default::Default::default(),
            timeout_next_step: core::default::Default::default(),
            timeout_response: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElRef {
        Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `failure_conditional` after provisioning.\n"]    pub fn failure_conditional (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureConditionalElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.failure_conditional", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `failure_next_step` after provisioning.\n"]    pub fn failure_next_step (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureNextStepElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.failure_next_step", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `failure_response` after provisioning.\n"]    pub fn failure_response (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElFailureResponseElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.failure_response", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `success_conditional` after provisioning.\n"]    pub fn success_conditional (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessConditionalElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.success_conditional", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `success_next_step` after provisioning.\n"]    pub fn success_next_step (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessNextStepElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.success_next_step", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `success_response` after provisioning.\n"]    pub fn success_response (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElSuccessResponseElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.success_response", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `timeout_conditional` after provisioning.\n"]    pub fn timeout_conditional (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutConditionalElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.timeout_conditional", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `timeout_next_step` after provisioning.\n"]    pub fn timeout_next_step (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutNextStepElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.timeout_next_step", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `timeout_response` after provisioning.\n"]    pub fn timeout_response (& self) -> ListRef < Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElTimeoutResponseElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.timeout_response", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentFulfillmentCodeHookElDynamic {
    fulfillment_updates_specification: Option<
        DynamicBlock<Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationEl>,
    >,
    post_fulfillment_status_specification: Option<
        DynamicBlock<Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationEl>,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentFulfillmentCodeHookEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    active: Option<PrimField<bool>>,
    enabled: PrimField<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    fulfillment_updates_specification:
        Option<Vec<Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    post_fulfillment_status_specification:
        Option<Vec<Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationEl>>,
    dynamic: Lexv2modelsIntentFulfillmentCodeHookElDynamic,
}
impl Lexv2modelsIntentFulfillmentCodeHookEl {
    #[doc = "Set the field `active`.\n"]
    pub fn set_active(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.active = Some(v.into());
        self
    }
    #[doc = "Set the field `fulfillment_updates_specification`.\n"]
    pub fn set_fulfillment_updates_specification(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.fulfillment_updates_specification = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.fulfillment_updates_specification = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `post_fulfillment_status_specification`.\n"]
    pub fn set_post_fulfillment_status_specification(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.post_fulfillment_status_specification = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.post_fulfillment_status_specification = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentFulfillmentCodeHookEl {
    type O = BlockAssignable<Lexv2modelsIntentFulfillmentCodeHookEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentFulfillmentCodeHookEl {
    #[doc = ""]
    pub enabled: PrimField<bool>,
}
impl BuildLexv2modelsIntentFulfillmentCodeHookEl {
    pub fn build(self) -> Lexv2modelsIntentFulfillmentCodeHookEl {
        Lexv2modelsIntentFulfillmentCodeHookEl {
            active: core::default::Default::default(),
            enabled: self.enabled,
            fulfillment_updates_specification: core::default::Default::default(),
            post_fulfillment_status_specification: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentFulfillmentCodeHookElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentFulfillmentCodeHookElRef {
    fn new(shared: StackShared, base: String) -> Lexv2modelsIntentFulfillmentCodeHookElRef {
        Lexv2modelsIntentFulfillmentCodeHookElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentFulfillmentCodeHookElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `active` after provisioning.\n"]
    pub fn active(&self) -> PrimExpr<bool> {
        PrimExpr::new(self.shared().clone(), format!("{}.active", self.base))
    }
    #[doc = "Get a reference to the value of field `enabled` after provisioning.\n"]
    pub fn enabled(&self) -> PrimExpr<bool> {
        PrimExpr::new(self.shared().clone(), format!("{}.enabled", self.base))
    }
    #[doc = "Get a reference to the value of field `fulfillment_updates_specification` after provisioning.\n"]
    pub fn fulfillment_updates_specification(
        &self,
    ) -> ListRef<Lexv2modelsIntentFulfillmentCodeHookElFulfillmentUpdatesSpecificationElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.fulfillment_updates_specification", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `post_fulfillment_status_specification` after provisioning.\n"]
    pub fn post_fulfillment_status_specification(
        &self,
    ) -> ListRef<Lexv2modelsIntentFulfillmentCodeHookElPostFulfillmentStatusSpecificationElRef>
    {
        ListRef::new(
            self.shared().clone(),
            format!("{}.post_fulfillment_status_specification", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl
{
    expression_string: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl
{
    #[doc = ""]
    pub expression_string: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl { expression_string : self . expression_string , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `expression_string` after provisioning.\n"] pub fn expression_string (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.expression_string" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElDynamic { condition : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl >> , next_step : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl { name : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] condition : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl > > , # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl { # [doc = "Set the field `condition`.\n"] pub fn set_condition (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . condition = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . condition = Some (d) ; } } self } # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl
{
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl { name : self . name , condition : core :: default :: Default :: default () , next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } # [doc = "Get a reference to the value of field `condition` after provisioning.\n"] pub fn condition (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElConditionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.condition" , self . base)) } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElDynamic { next_step : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl { # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl { # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl { next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDynamic { conditional_branch : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl >> , default_branch : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl { active : PrimField < bool > , # [serde (skip_serializing_if = "Option::is_none")] conditional_branch : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl > > , # [serde (skip_serializing_if = "Option::is_none")] default_branch : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl { # [doc = "Set the field `conditional_branch`.\n"] pub fn set_conditional_branch (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . conditional_branch = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . conditional_branch = Some (d) ; } } self } # [doc = "Set the field `default_branch`.\n"] pub fn set_default_branch (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . default_branch = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . default_branch = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl
{
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl { active : self . active , conditional_branch : core :: default :: Default :: default () , default_branch : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `active` after provisioning.\n"] pub fn active (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.active" , self . base)) } # [doc = "Get a reference to the value of field `conditional_branch` after provisioning.\n"] pub fn conditional_branch (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElConditionalBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.conditional_branch" , self . base)) } # [doc = "Get a reference to the value of field `default_branch` after provisioning.\n"] pub fn default_branch (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElDefaultBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.default_branch" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDynamic , }
impl
    Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl
{
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElDynamic , }
impl
    Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl
{
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl
{
    expression_string: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl
{
    #[doc = ""]
    pub expression_string: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl { expression_string : self . expression_string , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `expression_string` after provisioning.\n"] pub fn expression_string (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.expression_string" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElDynamic { condition : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl >> , next_step : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl { name : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] condition : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl > > , # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl { # [doc = "Set the field `condition`.\n"] pub fn set_condition (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . condition = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . condition = Some (d) ; } } self } # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl
{
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl { name : self . name , condition : core :: default :: Default :: default () , next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } # [doc = "Get a reference to the value of field `condition` after provisioning.\n"] pub fn condition (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElConditionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.condition" , self . base)) } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElDynamic { next_step : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl { # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl { # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl { next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDynamic { conditional_branch : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl >> , default_branch : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl { active : PrimField < bool > , # [serde (skip_serializing_if = "Option::is_none")] conditional_branch : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl > > , # [serde (skip_serializing_if = "Option::is_none")] default_branch : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl { # [doc = "Set the field `conditional_branch`.\n"] pub fn set_conditional_branch (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . conditional_branch = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . conditional_branch = Some (d) ; } } self } # [doc = "Set the field `default_branch`.\n"] pub fn set_default_branch (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . default_branch = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . default_branch = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl
{
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl { active : self . active , conditional_branch : core :: default :: Default :: default () , default_branch : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `active` after provisioning.\n"] pub fn active (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.active" , self . base)) } # [doc = "Get a reference to the value of field `conditional_branch` after provisioning.\n"] pub fn conditional_branch (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElConditionalBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.conditional_branch" , self . base)) } # [doc = "Get a reference to the value of field `default_branch` after provisioning.\n"] pub fn default_branch (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElDefaultBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.default_branch" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDynamic , }
impl
    Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl
{
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElDynamic , }
impl
    Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl
{
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl
{
    expression_string: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl
{
    #[doc = ""]
    pub expression_string: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl { expression_string : self . expression_string , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `expression_string` after provisioning.\n"] pub fn expression_string (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.expression_string" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElDynamic { condition : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl >> , next_step : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl { name : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] condition : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl > > , # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl { # [doc = "Set the field `condition`.\n"] pub fn set_condition (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . condition = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . condition = Some (d) ; } } self } # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl
{
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl { name : self . name , condition : core :: default :: Default :: default () , next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } # [doc = "Get a reference to the value of field `condition` after provisioning.\n"] pub fn condition (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElConditionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.condition" , self . base)) } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { # [doc = "Set the field `session_attributes`.\n"] pub fn set_session_attributes (mut self , v : impl Into < RecField < PrimField < String > > >) -> Self { self . session_attributes = Some (v . into ()) ; self } # [doc = "Set the field `dialog_action`.\n"] pub fn set_dialog_action (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . dialog_action = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . dialog_action = Some (d) ; } } self } # [doc = "Set the field `intent`.\n"] pub fn set_intent (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . intent = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . intent = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { # [doc = "Set the field `allow_interrupt`.\n"] pub fn set_allow_interrupt (mut self , v : impl Into < PrimField < bool > >) -> Self { self . allow_interrupt = Some (v . into ()) ; self } # [doc = "Set the field `message_group`.\n"] pub fn set_message_group (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message_group = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message_group = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElDynamic { next_step : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl >> , response : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl { # [serde (skip_serializing_if = "Option::is_none")] next_step : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] response : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl { # [doc = "Set the field `next_step`.\n"] pub fn set_next_step (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . next_step = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . next_step = Some (d) ; } } self } # [doc = "Set the field `response`.\n"] pub fn set_response (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . response = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . response = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl { next_step : core :: default :: Default :: default () , response : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `next_step` after provisioning.\n"] pub fn next_step (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElNextStepElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.next_step" , self . base)) } # [doc = "Get a reference to the value of field `response` after provisioning.\n"] pub fn response (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElResponseElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.response" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDynamic { conditional_branch : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl >> , default_branch : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl { active : PrimField < bool > , # [serde (skip_serializing_if = "Option::is_none")] conditional_branch : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl > > , # [serde (skip_serializing_if = "Option::is_none")] default_branch : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl { # [doc = "Set the field `conditional_branch`.\n"] pub fn set_conditional_branch (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . conditional_branch = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . conditional_branch = Some (d) ; } } self } # [doc = "Set the field `default_branch`.\n"] pub fn set_default_branch (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . default_branch = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . default_branch = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl
{
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl { active : self . active , conditional_branch : core :: default :: Default :: default () , default_branch : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `active` after provisioning.\n"] pub fn active (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.active" , self . base)) } # [doc = "Get a reference to the value of field `conditional_branch` after provisioning.\n"] pub fn conditional_branch (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElConditionalBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.conditional_branch" , self . base)) } # [doc = "Get a reference to the value of field `default_branch` after provisioning.\n"] pub fn default_branch (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElDefaultBranchElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.default_branch" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl { # [doc = "Set the field `name`.\n"] pub fn set_name (mut self , v : impl Into < PrimField < String > >) -> Self { self . name = Some (v . into ()) ; self } # [doc = "Set the field `slot`.\n"] pub fn set_slot (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElSlotEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . slot = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . slot = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `name` after provisioning.\n"] pub fn name (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.name" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDynamic , }
impl
    Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl
{
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl { session_attributes : core :: default :: Default :: default () , dialog_action : core :: default :: Default :: default () , intent : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"] pub fn session_attributes (& self) -> RecRef < PrimExpr < String > > { RecRef :: new (self . shared () . clone () , format ! ("{}.session_attributes" , self . base)) } # [doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"] pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElDialogActionElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.dialog_action" , self . base)) } # [doc = "Get a reference to the value of field `intent` after provisioning.\n"] pub fn intent (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElIntentElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.intent" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElDynamic , }
impl
    Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl
{
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl { allow_interrupt : core :: default :: Default :: default () , message_group : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElRef { Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"] pub fn allow_interrupt (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.allow_interrupt" , self . base)) } # [doc = "Get a reference to the value of field `message_group` after provisioning.\n"] pub fn message_group (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElMessageGroupElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message_group" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElDynamic { failure_conditional : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl >> , failure_next_step : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl >> , failure_response : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl >> , success_conditional : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl >> , success_next_step : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl >> , success_response : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl >> , timeout_conditional : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl >> , timeout_next_step : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl >> , timeout_response : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationEl { # [serde (skip_serializing_if = "Option::is_none")] failure_conditional : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl > > , # [serde (skip_serializing_if = "Option::is_none")] failure_next_step : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] failure_response : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl > > , # [serde (skip_serializing_if = "Option::is_none")] success_conditional : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl > > , # [serde (skip_serializing_if = "Option::is_none")] success_next_step : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] success_response : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl > > , # [serde (skip_serializing_if = "Option::is_none")] timeout_conditional : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl > > , # [serde (skip_serializing_if = "Option::is_none")] timeout_next_step : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl > > , # [serde (skip_serializing_if = "Option::is_none")] timeout_response : Option < Vec < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationEl {
    #[doc = "Set the field `failure_conditional`.\n"]
    pub fn set_failure_conditional(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.failure_conditional = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.failure_conditional = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `failure_next_step`.\n"]
    pub fn set_failure_next_step(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.failure_next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.failure_next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `failure_response`.\n"]
    pub fn set_failure_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.failure_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.failure_response = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `success_conditional`.\n"]
    pub fn set_success_conditional(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.success_conditional = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.success_conditional = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `success_next_step`.\n"]
    pub fn set_success_next_step(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.success_next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.success_next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `success_response`.\n"]
    pub fn set_success_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.success_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.success_response = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `timeout_conditional`.\n"]
    pub fn set_timeout_conditional(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.timeout_conditional = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.timeout_conditional = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `timeout_next_step`.\n"]
    pub fn set_timeout_next_step(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.timeout_next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.timeout_next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `timeout_response`.\n"]
    pub fn set_timeout_response(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.timeout_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.timeout_response = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationEl {}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationEl {
        Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationEl {
            failure_conditional: core::default::Default::default(),
            failure_next_step: core::default::Default::default(),
            failure_response: core::default::Default::default(),
            success_conditional: core::default::Default::default(),
            success_next_step: core::default::Default::default(),
            success_response: core::default::Default::default(),
            timeout_conditional: core::default::Default::default(),
            timeout_next_step: core::default::Default::default(),
            timeout_response: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElRef {
        Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `failure_conditional` after provisioning.\n"]    pub fn failure_conditional (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureConditionalElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.failure_conditional", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `failure_next_step` after provisioning.\n"]    pub fn failure_next_step (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureNextStepElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.failure_next_step", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `failure_response` after provisioning.\n"]    pub fn failure_response (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElFailureResponseElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.failure_response", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `success_conditional` after provisioning.\n"]    pub fn success_conditional (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessConditionalElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.success_conditional", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `success_next_step` after provisioning.\n"]    pub fn success_next_step (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessNextStepElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.success_next_step", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `success_response` after provisioning.\n"]    pub fn success_response (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElSuccessResponseElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.success_response", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `timeout_conditional` after provisioning.\n"]    pub fn timeout_conditional (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutConditionalElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.timeout_conditional", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `timeout_next_step` after provisioning.\n"]    pub fn timeout_next_step (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutNextStepElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.timeout_next_step", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `timeout_response` after provisioning.\n"]    pub fn timeout_response (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElTimeoutResponseElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.timeout_response", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElCodeHookElDynamic {
    post_code_hook_specification: Option<
        DynamicBlock<
            Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookEl {
    active: PrimField<bool>,
    enable_code_hook_invocation: PrimField<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    invocation_label: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    post_code_hook_specification:
        Option<Vec<Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationEl>>,
    dynamic: Lexv2modelsIntentInitialResponseSettingElCodeHookElDynamic,
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookEl {
    #[doc = "Set the field `invocation_label`.\n"]
    pub fn set_invocation_label(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.invocation_label = Some(v.into());
        self
    }
    #[doc = "Set the field `post_code_hook_specification`.\n"]
    pub fn set_post_code_hook_specification(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.post_code_hook_specification = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.post_code_hook_specification = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElCodeHookEl {
    type O = BlockAssignable<Lexv2modelsIntentInitialResponseSettingElCodeHookEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElCodeHookEl {
    #[doc = ""]
    pub active: PrimField<bool>,
    #[doc = ""]
    pub enable_code_hook_invocation: PrimField<bool>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElCodeHookEl {
    pub fn build(self) -> Lexv2modelsIntentInitialResponseSettingElCodeHookEl {
        Lexv2modelsIntentInitialResponseSettingElCodeHookEl {
            active: self.active,
            enable_code_hook_invocation: self.enable_code_hook_invocation,
            invocation_label: core::default::Default::default(),
            post_code_hook_specification: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElCodeHookElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElCodeHookElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElCodeHookElRef {
        Lexv2modelsIntentInitialResponseSettingElCodeHookElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElCodeHookElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `active` after provisioning.\n"]
    pub fn active(&self) -> PrimExpr<bool> {
        PrimExpr::new(self.shared().clone(), format!("{}.active", self.base))
    }
    #[doc = "Get a reference to the value of field `enable_code_hook_invocation` after provisioning.\n"]
    pub fn enable_code_hook_invocation(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.enable_code_hook_invocation", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `invocation_label` after provisioning.\n"]
    pub fn invocation_label(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.invocation_label", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `post_code_hook_specification` after provisioning.\n"]
    pub fn post_code_hook_specification(
        &self,
    ) -> ListRef<Lexv2modelsIntentInitialResponseSettingElCodeHookElPostCodeHookSpecificationElRef>
    {
        ListRef::new(
            self.shared().clone(),
            format!("{}.post_code_hook_specification", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionEl {
    expression_string: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionEl {}
impl ToListMappable
    for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionEl
{
    #[doc = ""]
    pub expression_string: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionEl {
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionEl {
            expression_string: self.expression_string,
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionElRef {
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionElRef
    {
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `expression_string` after provisioning.\n"]
    pub fn expression_string(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.expression_string", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionEl { # [doc = "Set the field `slot_to_elicit`.\n"] pub fn set_slot_to_elicit (mut self , v : impl Into < PrimField < String > >) -> Self { self . slot_to_elicit = Some (v . into ()) ; self } # [doc = "Set the field `suppress_next_message`.\n"] pub fn set_suppress_next_message (mut self , v : impl Into < PrimField < bool > >) -> Self { self . suppress_next_message = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"] pub fn slot_to_elicit (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.slot_to_elicit" , self . base)) } # [doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"] pub fn suppress_next_message (& self) -> PrimExpr < bool > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.suppress_next_message" , self . base)) } # [doc = "Get a reference to the value of field `type_` after provisioning.\n"] pub fn type_ (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.type" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl { # [doc = "Set the field `shape`.\n"] pub fn set_shape (mut self , v : impl Into < PrimField < String > >) -> Self { self . shape = Some (v . into ()) ; self } # [doc = "Set the field `value`.\n"] pub fn set_value (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . value = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . value = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"] pub fn map_block_key (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.map_block_key" , self . base)) } # [doc = "Get a reference to the value of field `shape` after provisioning.\n"] pub fn shape (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.shape" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotElValueElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentEl {
    #[doc = "Set the field `name`.\n"]
    pub fn set_name(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.name = Some(v.into());
        self
    }
    #[doc = "Set the field `slot`.\n"]
    pub fn set_slot(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElSlotEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.slot = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.slot = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentEl
{}
impl
    BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentEl
{
    pub fn build(
        self,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentEl
    {
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentEl { name : core :: default :: Default :: default () , slot : core :: default :: Default :: default () , dynamic : Default :: default () , }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepEl {
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepEl {
            session_attributes: core::default::Default::default(),
            dialog_action: core::default::Default::default(),
            intent: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElRef {
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElRef
    {
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]    pub fn intent (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElIntentElRef >{
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupEl { # [doc = "Set the field `message`.\n"] pub fn set_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . message = Some (d) ; } } self } # [doc = "Set the field `variation`.\n"] pub fn set_variation (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . variation = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . variation = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupEl { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `message` after provisioning.\n"] pub fn message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.message" , self . base)) } # [doc = "Get a reference to the value of field `variation` after provisioning.\n"] pub fn variation (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElVariationElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.variation" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseEl {
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseEl {
            allow_interrupt: core::default::Default::default(),
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElRef {
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElRef
    {
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElDynamic {
    condition: Option<
        DynamicBlock<
            Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionEl,
        >,
    >,
    next_step: Option<
        DynamicBlock<
            Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepEl,
        >,
    >,
    response: Option<
        DynamicBlock<
            Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchEl {
    name: PrimField<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    condition: Option<
        Vec<Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionEl>,
    >,
    #[serde(skip_serializing_if = "Option::is_none")]
    next_step: Option<
        Vec<Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepEl>,
    >,
    #[serde(skip_serializing_if = "Option::is_none")]
    response: Option<
        Vec<Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseEl>,
    >,
    dynamic: Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElDynamic,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchEl {
    #[doc = "Set the field `condition`.\n"]
    pub fn set_condition(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.condition = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.condition = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `next_step`.\n"]
    pub fn set_next_step(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `response`.\n"]
    pub fn set_response(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.response = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchEl {
    type O =
        BlockAssignable<Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchEl {
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchEl {
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchEl {
            name: self.name,
            condition: core::default::Default::default(),
            next_step: core::default::Default::default(),
            response: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElRef {
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
    #[doc = "Get a reference to the value of field `condition` after provisioning.\n"]
    pub fn condition(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElConditionElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.condition", self.base))
    }
    #[doc = "Get a reference to the value of field `next_step` after provisioning.\n"]
    pub fn next_step(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElNextStepElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.next_step", self.base))
    }
    #[doc = "Get a reference to the value of field `response` after provisioning.\n"]
    pub fn response(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElResponseElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.response", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionEl {
    #[doc = "Set the field `slot_to_elicit`.\n"]
    pub fn set_slot_to_elicit(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.slot_to_elicit = Some(v.into());
        self
    }
    #[doc = "Set the field `suppress_next_message`.\n"]
    pub fn set_suppress_next_message(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.suppress_next_message = Some(v.into());
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionEl
{
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionEl { slot_to_elicit : core :: default :: Default :: default () , suppress_next_message : core :: default :: Default :: default () , type_ : self . type_ , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"]
    pub fn slot_to_elicit(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.slot_to_elicit", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"]
    pub fn suppress_next_message(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.suppress_next_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `type_` after provisioning.\n"]
    pub fn type_(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.type", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { # [doc = "Set the field `interpreted_value`.\n"] pub fn set_interpreted_value (mut self , v : impl Into < PrimField < String > >) -> Self { self . interpreted_value = Some (v . into ()) ; self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl { interpreted_value : core :: default :: Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"] pub fn interpreted_value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.interpreted_value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic { value : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] shape : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] value : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl {
    #[doc = "Set the field `shape`.\n"]
    pub fn set_shape(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.shape = Some(v.into());
        self
    }
    #[doc = "Set the field `value`.\n"]
    pub fn set_value(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.value = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.value = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl
{
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl { map_block_key : self . map_block_key , shape : core :: default :: Default :: default () , value : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"]
    pub fn map_block_key(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.map_block_key", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `shape` after provisioning.\n"]
    pub fn shape(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.shape", self.base))
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]    pub fn value (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotElValueElRef >{
        ListRef::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElDynamic { slot : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentEl { # [serde (skip_serializing_if = "Option::is_none")] name : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] slot : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentEl {
    #[doc = "Set the field `name`.\n"]
    pub fn set_name(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.name = Some(v.into());
        self
    }
    #[doc = "Set the field `slot`.\n"]
    pub fn set_slot(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElSlotEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.slot = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.slot = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentEl
    {
        Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentEl {
            name: core::default::Default::default(),
            slot: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElRef
{
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElRef
    {
        Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDynamic { dialog_action : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionEl >> , intent : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepEl { # [serde (skip_serializing_if = "Option::is_none")] session_attributes : Option < RecField < PrimField < String > > > , # [serde (skip_serializing_if = "Option::is_none")] dialog_action : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionEl > > , # [serde (skip_serializing_if = "Option::is_none")] intent : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepEl {}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepEl {
        Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepEl {
            session_attributes: core::default::Default::default(),
            dialog_action: core::default::Default::default(),
            intent: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElRef {
        Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]    pub fn dialog_action (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElDialogActionElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]
    pub fn intent(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElIntentElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { # [doc = "Set the field `custom_payload`.\n"] pub fn set_custom_payload (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . custom_payload = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . custom_payload = Some (d) ; } } self } # [doc = "Set the field `image_response_card`.\n"] pub fn set_image_response_card (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . image_response_card = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . image_response_card = Some (d) ; } } self } # [doc = "Set the field `plain_text_message`.\n"] pub fn set_plain_text_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . plain_text_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . plain_text_message = Some (d) ; } } self } # [doc = "Set the field `ssml_message`.\n"] pub fn set_ssml_message (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . ssml_message = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . ssml_message = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl { custom_payload : core :: default :: Default :: default () , image_response_card : core :: default :: Default :: default () , plain_text_message : core :: default :: Default :: default () , ssml_message : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"] pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElCustomPayloadElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.custom_payload" , self . base)) } # [doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"] pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElImageResponseCardElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.image_response_card" , self . base)) } # [doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"] pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElPlainTextMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.plain_text_message" , self . base)) } # [doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"] pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElSsmlMessageElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.ssml_message" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElDynamic { message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >> , variation : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupEl { # [serde (skip_serializing_if = "Option::is_none")] message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] variation : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupEl {
    #[doc = "Set the field `message`.\n"]
    pub fn set_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `variation`.\n"]
    pub fn set_variation(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.variation = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.variation = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupEl { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupEl { message : core :: default :: Default :: default () , variation : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElRef { Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElRef { shared : shared , base : base . to_string () , } } }
impl
    Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElRef
{
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `message` after provisioning.\n"]    pub fn message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElMessageElRef >{
        ListRef::new(self.shared().clone(), format!("{}.message", self.base))
    }
    #[doc = "Get a reference to the value of field `variation` after provisioning.\n"]    pub fn variation (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElVariationElRef >{
        ListRef::new(self.shared().clone(), format!("{}.variation", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElDynamic { message_group : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseEl { # [serde (skip_serializing_if = "Option::is_none")] allow_interrupt : Option < PrimField < bool > > , # [serde (skip_serializing_if = "Option::is_none")] message_group : Option < Vec < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseEl {}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseEl {
        Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseEl {
            allow_interrupt: core::default::Default::default(),
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElRef {
        Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]    pub fn message_group (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElMessageGroupElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElDynamic {
    next_step: Option<
        DynamicBlock<
            Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepEl,
        >,
    >,
    response: Option<
        DynamicBlock<
            Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    next_step: Option<
        Vec<Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepEl>,
    >,
    #[serde(skip_serializing_if = "Option::is_none")]
    response: Option<
        Vec<Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseEl>,
    >,
    dynamic: Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElDynamic,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchEl {
    #[doc = "Set the field `next_step`.\n"]
    pub fn set_next_step(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.next_step = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `response`.\n"]
    pub fn set_response(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.response = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchEl {
    type O = BlockAssignable<Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchEl {}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchEl {
    pub fn build(self) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchEl {
        Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchEl {
            next_step: core::default::Default::default(),
            response: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElRef {
        Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `next_step` after provisioning.\n"]
    pub fn next_step(
        &self,
    ) -> ListRef<Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElNextStepElRef>
    {
        ListRef::new(self.shared().clone(), format!("{}.next_step", self.base))
    }
    #[doc = "Get a reference to the value of field `response` after provisioning.\n"]
    pub fn response(
        &self,
    ) -> ListRef<Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElResponseElRef>
    {
        ListRef::new(self.shared().clone(), format!("{}.response", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElConditionalElDynamic {
    conditional_branch: Option<
        DynamicBlock<Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchEl>,
    >,
    default_branch:
        Option<DynamicBlock<Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalEl {
    active: PrimField<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    conditional_branch:
        Option<Vec<Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    default_branch:
        Option<Vec<Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchEl>>,
    dynamic: Lexv2modelsIntentInitialResponseSettingElConditionalElDynamic,
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalEl {
    #[doc = "Set the field `conditional_branch`.\n"]
    pub fn set_conditional_branch(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.conditional_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.conditional_branch = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `default_branch`.\n"]
    pub fn set_default_branch(
        mut self,
        v: impl Into<
            BlockAssignable<Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchEl>,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.default_branch = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.default_branch = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElConditionalEl {
    type O = BlockAssignable<Lexv2modelsIntentInitialResponseSettingElConditionalEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElConditionalEl {
    #[doc = ""]
    pub active: PrimField<bool>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElConditionalEl {
    pub fn build(self) -> Lexv2modelsIntentInitialResponseSettingElConditionalEl {
        Lexv2modelsIntentInitialResponseSettingElConditionalEl {
            active: self.active,
            conditional_branch: core::default::Default::default(),
            default_branch: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElConditionalElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElConditionalElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElConditionalElRef {
        Lexv2modelsIntentInitialResponseSettingElConditionalElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElConditionalElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `active` after provisioning.\n"]
    pub fn active(&self) -> PrimExpr<bool> {
        PrimExpr::new(self.shared().clone(), format!("{}.active", self.base))
    }
    #[doc = "Get a reference to the value of field `conditional_branch` after provisioning.\n"]
    pub fn conditional_branch(
        &self,
    ) -> ListRef<Lexv2modelsIntentInitialResponseSettingElConditionalElConditionalBranchElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.conditional_branch", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `default_branch` after provisioning.\n"]
    pub fn default_branch(
        &self,
    ) -> ListRef<Lexv2modelsIntentInitialResponseSettingElConditionalElDefaultBranchElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.default_branch", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadEl
{
    value: PrimField<String>,
}
impl
    Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadEl
{
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageEl
{
    value: PrimField<String>,
}
impl
    Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageEl
{
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageEl {
    #[doc = "Set the field `custom_payload`.\n"]
    pub fn set_custom_payload(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.custom_payload = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.custom_payload = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `image_response_card`.\n"]
    pub fn set_image_response_card(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.image_response_card = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.image_response_card = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `plain_text_message`.\n"]
    pub fn set_plain_text_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.plain_text_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.plain_text_message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `ssml_message`.\n"]
    pub fn set_ssml_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.ssml_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.ssml_message = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageEl {
}
impl BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageEl {
        Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageEl {
            custom_payload: core::default::Default::default(),
            image_response_card: core::default::Default::default(),
            plain_text_message: core::default::Default::default(),
            ssml_message: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElRef {
        Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"]    pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElCustomPayloadElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.custom_payload", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"]    pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElImageResponseCardElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.image_response_card", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"]    pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElPlainTextMessageElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.plain_text_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"]    pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElSsmlMessageElRef >{
        ListRef::new(self.shared().clone(), format!("{}.ssml_message", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadEl { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadElRef { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    text: PrimField<String>,
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonEl
{
    #[doc = ""]
    pub text: PrimField<String>,
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonEl { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonEl { text : self . text , value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `text` after provisioning.\n"] pub fn text (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.text" , self . base)) } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElDynamic { button : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardEl { # [serde (skip_serializing_if = "Option::is_none")] image_url : Option < PrimField < String > > , # [serde (skip_serializing_if = "Option::is_none")] subtitle : Option < PrimField < String > > , title : PrimField < String > , # [serde (skip_serializing_if = "Option::is_none")] button : Option < Vec < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardEl { # [doc = "Set the field `image_url`.\n"] pub fn set_image_url (mut self , v : impl Into < PrimField < String > >) -> Self { self . image_url = Some (v . into ()) ; self } # [doc = "Set the field `subtitle`.\n"] pub fn set_subtitle (mut self , v : impl Into < PrimField < String > >) -> Self { self . subtitle = Some (v . into ()) ; self } # [doc = "Set the field `button`.\n"] pub fn set_button (mut self , v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonEl >>) -> Self { match v . into () { BlockAssignable :: Literal (v) => { self . button = Some (v) ; } , BlockAssignable :: Dynamic (d) => { self . dynamic . button = Some (d) ; } } self } }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardEl
{
    #[doc = ""]
    pub title: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardEl { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardEl { image_url : core :: default :: Default :: default () , subtitle : core :: default :: Default :: default () , title : self . title , button : core :: default :: Default :: default () , dynamic : Default :: default () , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElRef { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `image_url` after provisioning.\n"] pub fn image_url (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.image_url" , self . base)) } # [doc = "Get a reference to the value of field `subtitle` after provisioning.\n"] pub fn subtitle (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.subtitle" , self . base)) } # [doc = "Get a reference to the value of field `title` after provisioning.\n"] pub fn title (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.title" , self . base)) } # [doc = "Get a reference to the value of field `button` after provisioning.\n"] pub fn button (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElButtonElRef > { ListRef :: new (self . shared () . clone () , format ! ("{}.button" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageEl
{
    value: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageEl { }
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageEl { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageElRef { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageEl
{
    value: PrimField<String>,
}
impl
    Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageEl
{
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageEl { type O = BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageEl > ; fn do_map (self , base : String) -> Self :: O { BlockAssignable :: Dynamic (DynamicBlock { for_each : format ! ("${{{}}}" , base) , iterator : "each" . into () , content : self , }) } }
pub struct BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageEl
{
    #[doc = ""]
    pub value: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageEl { pub fn build (self) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageEl { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageEl { value : self . value , } } }
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageElRef
{
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageElRef { fn new (shared : StackShared , base : String) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageElRef { Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageElRef { shared : shared , base : base . to_string () , } } }
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageElRef { fn shared (& self) -> & StackShared { & self . shared } # [doc = "Get a reference to the value of field `value` after provisioning.\n"] pub fn value (& self) -> PrimExpr < String > { PrimExpr :: new (self . shared () . clone () , format ! ("{}.value" , self . base)) } }
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElDynamic { custom_payload : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadEl >> , image_response_card : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardEl >> , plain_text_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageEl >> , ssml_message : Option < DynamicBlock < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageEl >> , }
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationEl { # [serde (skip_serializing_if = "Option::is_none")] custom_payload : Option < Vec < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadEl > > , # [serde (skip_serializing_if = "Option::is_none")] image_response_card : Option < Vec < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardEl > > , # [serde (skip_serializing_if = "Option::is_none")] plain_text_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageEl > > , # [serde (skip_serializing_if = "Option::is_none")] ssml_message : Option < Vec < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageEl > > , dynamic : Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElDynamic , }
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationEl {
    #[doc = "Set the field `custom_payload`.\n"]
    pub fn set_custom_payload(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.custom_payload = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.custom_payload = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `image_response_card`.\n"]
    pub fn set_image_response_card(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.image_response_card = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.image_response_card = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `plain_text_message`.\n"]
    pub fn set_plain_text_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.plain_text_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.plain_text_message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `ssml_message`.\n"]
    pub fn set_ssml_message(
        mut self,
        v : impl Into < BlockAssignable < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageEl >>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.ssml_message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.ssml_message = Some(d);
            }
        }
        self
    }
}
impl ToListMappable
    for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationEl
{
    type O = BlockAssignable<
        Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationEl,
    >;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationEl
{}
impl BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationEl {
    pub fn build(
        self,
    ) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationEl {
        Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationEl {
            custom_payload: core::default::Default::default(),
            image_response_card: core::default::Default::default(),
            plain_text_message: core::default::Default::default(),
            ssml_message: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElRef {
    shared: StackShared,
    base: String,
}
impl Ref
    for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElRef
{
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElRef
    {
        Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `custom_payload` after provisioning.\n"]    pub fn custom_payload (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElCustomPayloadElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.custom_payload", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `image_response_card` after provisioning.\n"]    pub fn image_response_card (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElImageResponseCardElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.image_response_card", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `plain_text_message` after provisioning.\n"]    pub fn plain_text_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElPlainTextMessageElRef >{
        ListRef::new(
            self.shared().clone(),
            format!("{}.plain_text_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `ssml_message` after provisioning.\n"]    pub fn ssml_message (& self) -> ListRef < Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElSsmlMessageElRef >{
        ListRef::new(self.shared().clone(), format!("{}.ssml_message", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElDynamic {
    message: Option<
        DynamicBlock<
            Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageEl,
        >,
    >,
    variation: Option<
        DynamicBlock<
            Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationEl,
        >,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    message: Option<
        Vec<Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageEl>,
    >,
    #[serde(skip_serializing_if = "Option::is_none")]
    variation: Option<
        Vec<Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationEl>,
    >,
    dynamic: Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElDynamic,
}
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupEl {
    #[doc = "Set the field `message`.\n"]
    pub fn set_message(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `variation`.\n"]
    pub fn set_variation(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.variation = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.variation = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupEl {
    type O =
        BlockAssignable<Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupEl {}
impl BuildLexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupEl {
    pub fn build(self) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupEl {
        Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupEl {
            message: core::default::Default::default(),
            variation: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElRef {
        Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `message` after provisioning.\n"]
    pub fn message(
        &self,
    ) -> ListRef<Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElMessageElRef>
    {
        ListRef::new(self.shared().clone(), format!("{}.message", self.base))
    }
    #[doc = "Get a reference to the value of field `variation` after provisioning.\n"]
    pub fn variation(
        &self,
    ) -> ListRef<
        Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElVariationElRef,
    > {
        ListRef::new(self.shared().clone(), format!("{}.variation", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElDynamic {
    message_group: Option<
        DynamicBlock<Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupEl>,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    allow_interrupt: Option<PrimField<bool>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    message_group:
        Option<Vec<Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupEl>>,
    dynamic: Lexv2modelsIntentInitialResponseSettingElInitialResponseElDynamic,
}
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseEl {
    #[doc = "Set the field `allow_interrupt`.\n"]
    pub fn set_allow_interrupt(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.allow_interrupt = Some(v.into());
        self
    }
    #[doc = "Set the field `message_group`.\n"]
    pub fn set_message_group(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.message_group = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.message_group = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElInitialResponseEl {
    type O = BlockAssignable<Lexv2modelsIntentInitialResponseSettingElInitialResponseEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElInitialResponseEl {}
impl BuildLexv2modelsIntentInitialResponseSettingElInitialResponseEl {
    pub fn build(self) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseEl {
        Lexv2modelsIntentInitialResponseSettingElInitialResponseEl {
            allow_interrupt: core::default::Default::default(),
            message_group: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElInitialResponseElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElInitialResponseElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElInitialResponseElRef {
        Lexv2modelsIntentInitialResponseSettingElInitialResponseElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElInitialResponseElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `allow_interrupt` after provisioning.\n"]
    pub fn allow_interrupt(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.allow_interrupt", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `message_group` after provisioning.\n"]
    pub fn message_group(
        &self,
    ) -> ListRef<Lexv2modelsIntentInitialResponseSettingElInitialResponseElMessageGroupElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.message_group", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    slot_to_elicit: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    suppress_next_message: Option<PrimField<bool>>,
    #[serde(rename = "type")]
    type_: PrimField<String>,
}
impl Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionEl {
    #[doc = "Set the field `slot_to_elicit`.\n"]
    pub fn set_slot_to_elicit(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.slot_to_elicit = Some(v.into());
        self
    }
    #[doc = "Set the field `suppress_next_message`.\n"]
    pub fn set_suppress_next_message(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.suppress_next_message = Some(v.into());
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionEl {
    type O = BlockAssignable<Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElNextStepElDialogActionEl {
    #[doc = ""]
    pub type_: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElNextStepElDialogActionEl {
    pub fn build(self) -> Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionEl {
        Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionEl {
            slot_to_elicit: core::default::Default::default(),
            suppress_next_message: core::default::Default::default(),
            type_: self.type_,
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionElRef {
        Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `slot_to_elicit` after provisioning.\n"]
    pub fn slot_to_elicit(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.slot_to_elicit", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `suppress_next_message` after provisioning.\n"]
    pub fn suppress_next_message(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.suppress_next_message", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `type_` after provisioning.\n"]
    pub fn type_(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.type", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    interpreted_value: Option<PrimField<String>>,
}
impl Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueEl {
    #[doc = "Set the field `interpreted_value`.\n"]
    pub fn set_interpreted_value(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.interpreted_value = Some(v.into());
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueEl {
    type O =
        BlockAssignable<Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueEl {}
impl BuildLexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueEl {
    pub fn build(self) -> Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueEl {
        Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueEl {
            interpreted_value: core::default::Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueElRef {
        Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `interpreted_value` after provisioning.\n"]
    pub fn interpreted_value(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.interpreted_value", self.base),
        )
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElDynamic {
    value: Option<
        DynamicBlock<Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueEl>,
    >,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotEl {
    map_block_key: PrimField<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    shape: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    value: Option<Vec<Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueEl>>,
    dynamic: Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElDynamic,
}
impl Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotEl {
    #[doc = "Set the field `shape`.\n"]
    pub fn set_shape(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.shape = Some(v.into());
        self
    }
    #[doc = "Set the field `value`.\n"]
    pub fn set_value(
        mut self,
        v: impl Into<
            BlockAssignable<
                Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueEl,
            >,
        >,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.value = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.value = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotEl {
    type O = BlockAssignable<Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotEl {
    #[doc = ""]
    pub map_block_key: PrimField<String>,
}
impl BuildLexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotEl {
    pub fn build(self) -> Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotEl {
        Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotEl {
            map_block_key: self.map_block_key,
            shape: core::default::Default::default(),
            value: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElRef {
        Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `map_block_key` after provisioning.\n"]
    pub fn map_block_key(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.map_block_key", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `shape` after provisioning.\n"]
    pub fn shape(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.shape", self.base))
    }
    #[doc = "Get a reference to the value of field `value` after provisioning.\n"]
    pub fn value(
        &self,
    ) -> ListRef<Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotElValueElRef> {
        ListRef::new(self.shared().clone(), format!("{}.value", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElDynamic {
    slot: Option<DynamicBlock<Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElNextStepElIntentEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    name: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    slot: Option<Vec<Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotEl>>,
    dynamic: Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElDynamic,
}
impl Lexv2modelsIntentInitialResponseSettingElNextStepElIntentEl {
    #[doc = "Set the field `name`.\n"]
    pub fn set_name(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.name = Some(v.into());
        self
    }
    #[doc = "Set the field `slot`.\n"]
    pub fn set_slot(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElSlotEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.slot = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.slot = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElNextStepElIntentEl {
    type O = BlockAssignable<Lexv2modelsIntentInitialResponseSettingElNextStepElIntentEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElNextStepElIntentEl {}
impl BuildLexv2modelsIntentInitialResponseSettingElNextStepElIntentEl {
    pub fn build(self) -> Lexv2modelsIntentInitialResponseSettingElNextStepElIntentEl {
        Lexv2modelsIntentInitialResponseSettingElNextStepElIntentEl {
            name: core::default::Default::default(),
            slot: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElRef {
        Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElNextStepElDynamic {
    dialog_action:
        Option<DynamicBlock<Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionEl>>,
    intent: Option<DynamicBlock<Lexv2modelsIntentInitialResponseSettingElNextStepElIntentEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingElNextStepEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    session_attributes: Option<RecField<PrimField<String>>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    dialog_action: Option<Vec<Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    intent: Option<Vec<Lexv2modelsIntentInitialResponseSettingElNextStepElIntentEl>>,
    dynamic: Lexv2modelsIntentInitialResponseSettingElNextStepElDynamic,
}
impl Lexv2modelsIntentInitialResponseSettingElNextStepEl {
    #[doc = "Set the field `session_attributes`.\n"]
    pub fn set_session_attributes(mut self, v: impl Into<RecField<PrimField<String>>>) -> Self {
        self.session_attributes = Some(v.into());
        self
    }
    #[doc = "Set the field `dialog_action`.\n"]
    pub fn set_dialog_action(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.dialog_action = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.dialog_action = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `intent`.\n"]
    pub fn set_intent(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentInitialResponseSettingElNextStepElIntentEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.intent = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.intent = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingElNextStepEl {
    type O = BlockAssignable<Lexv2modelsIntentInitialResponseSettingElNextStepEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingElNextStepEl {}
impl BuildLexv2modelsIntentInitialResponseSettingElNextStepEl {
    pub fn build(self) -> Lexv2modelsIntentInitialResponseSettingElNextStepEl {
        Lexv2modelsIntentInitialResponseSettingElNextStepEl {
            session_attributes: core::default::Default::default(),
            dialog_action: core::default::Default::default(),
            intent: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElNextStepElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElNextStepElRef {
    fn new(
        shared: StackShared,
        base: String,
    ) -> Lexv2modelsIntentInitialResponseSettingElNextStepElRef {
        Lexv2modelsIntentInitialResponseSettingElNextStepElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElNextStepElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `session_attributes` after provisioning.\n"]
    pub fn session_attributes(&self) -> RecRef<PrimExpr<String>> {
        RecRef::new(
            self.shared().clone(),
            format!("{}.session_attributes", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `dialog_action` after provisioning.\n"]
    pub fn dialog_action(
        &self,
    ) -> ListRef<Lexv2modelsIntentInitialResponseSettingElNextStepElDialogActionElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.dialog_action", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `intent` after provisioning.\n"]
    pub fn intent(
        &self,
    ) -> ListRef<Lexv2modelsIntentInitialResponseSettingElNextStepElIntentElRef> {
        ListRef::new(self.shared().clone(), format!("{}.intent", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentInitialResponseSettingElDynamic {
    code_hook: Option<DynamicBlock<Lexv2modelsIntentInitialResponseSettingElCodeHookEl>>,
    conditional: Option<DynamicBlock<Lexv2modelsIntentInitialResponseSettingElConditionalEl>>,
    initial_response:
        Option<DynamicBlock<Lexv2modelsIntentInitialResponseSettingElInitialResponseEl>>,
    next_step: Option<DynamicBlock<Lexv2modelsIntentInitialResponseSettingElNextStepEl>>,
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInitialResponseSettingEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    code_hook: Option<Vec<Lexv2modelsIntentInitialResponseSettingElCodeHookEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    conditional: Option<Vec<Lexv2modelsIntentInitialResponseSettingElConditionalEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    initial_response: Option<Vec<Lexv2modelsIntentInitialResponseSettingElInitialResponseEl>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    next_step: Option<Vec<Lexv2modelsIntentInitialResponseSettingElNextStepEl>>,
    dynamic: Lexv2modelsIntentInitialResponseSettingElDynamic,
}
impl Lexv2modelsIntentInitialResponseSettingEl {
    #[doc = "Set the field `code_hook`.\n"]
    pub fn set_code_hook(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentInitialResponseSettingElCodeHookEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.code_hook = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.code_hook = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `conditional`.\n"]
    pub fn set_conditional(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentInitialResponseSettingElConditionalEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.conditional = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.conditional = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `initial_response`.\n"]
    pub fn set_initial_response(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentInitialResponseSettingElInitialResponseEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.initial_response = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.initial_response = Some(d);
            }
        }
        self
    }
    #[doc = "Set the field `next_step`.\n"]
    pub fn set_next_step(
        mut self,
        v: impl Into<BlockAssignable<Lexv2modelsIntentInitialResponseSettingElNextStepEl>>,
    ) -> Self {
        match v.into() {
            BlockAssignable::Literal(v) => {
                self.next_step = Some(v);
            }
            BlockAssignable::Dynamic(d) => {
                self.dynamic.next_step = Some(d);
            }
        }
        self
    }
}
impl ToListMappable for Lexv2modelsIntentInitialResponseSettingEl {
    type O = BlockAssignable<Lexv2modelsIntentInitialResponseSettingEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInitialResponseSettingEl {}
impl BuildLexv2modelsIntentInitialResponseSettingEl {
    pub fn build(self) -> Lexv2modelsIntentInitialResponseSettingEl {
        Lexv2modelsIntentInitialResponseSettingEl {
            code_hook: core::default::Default::default(),
            conditional: core::default::Default::default(),
            initial_response: core::default::Default::default(),
            next_step: core::default::Default::default(),
            dynamic: Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentInitialResponseSettingElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInitialResponseSettingElRef {
    fn new(shared: StackShared, base: String) -> Lexv2modelsIntentInitialResponseSettingElRef {
        Lexv2modelsIntentInitialResponseSettingElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInitialResponseSettingElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `code_hook` after provisioning.\n"]
    pub fn code_hook(&self) -> ListRef<Lexv2modelsIntentInitialResponseSettingElCodeHookElRef> {
        ListRef::new(self.shared().clone(), format!("{}.code_hook", self.base))
    }
    #[doc = "Get a reference to the value of field `conditional` after provisioning.\n"]
    pub fn conditional(
        &self,
    ) -> ListRef<Lexv2modelsIntentInitialResponseSettingElConditionalElRef> {
        ListRef::new(self.shared().clone(), format!("{}.conditional", self.base))
    }
    #[doc = "Get a reference to the value of field `initial_response` after provisioning.\n"]
    pub fn initial_response(
        &self,
    ) -> ListRef<Lexv2modelsIntentInitialResponseSettingElInitialResponseElRef> {
        ListRef::new(
            self.shared().clone(),
            format!("{}.initial_response", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `next_step` after provisioning.\n"]
    pub fn next_step(&self) -> ListRef<Lexv2modelsIntentInitialResponseSettingElNextStepElRef> {
        ListRef::new(self.shared().clone(), format!("{}.next_step", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentInputContextEl {
    name: PrimField<String>,
}
impl Lexv2modelsIntentInputContextEl {}
impl ToListMappable for Lexv2modelsIntentInputContextEl {
    type O = BlockAssignable<Lexv2modelsIntentInputContextEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentInputContextEl {
    #[doc = ""]
    pub name: PrimField<String>,
}
impl BuildLexv2modelsIntentInputContextEl {
    pub fn build(self) -> Lexv2modelsIntentInputContextEl {
        Lexv2modelsIntentInputContextEl { name: self.name }
    }
}
pub struct Lexv2modelsIntentInputContextElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentInputContextElRef {
    fn new(shared: StackShared, base: String) -> Lexv2modelsIntentInputContextElRef {
        Lexv2modelsIntentInputContextElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentInputContextElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentKendraConfigurationEl {
    kendra_index: PrimField<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    query_filter_string: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    query_filter_string_enabled: Option<PrimField<bool>>,
}
impl Lexv2modelsIntentKendraConfigurationEl {
    #[doc = "Set the field `query_filter_string`.\n"]
    pub fn set_query_filter_string(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.query_filter_string = Some(v.into());
        self
    }
    #[doc = "Set the field `query_filter_string_enabled`.\n"]
    pub fn set_query_filter_string_enabled(mut self, v: impl Into<PrimField<bool>>) -> Self {
        self.query_filter_string_enabled = Some(v.into());
        self
    }
}
impl ToListMappable for Lexv2modelsIntentKendraConfigurationEl {
    type O = BlockAssignable<Lexv2modelsIntentKendraConfigurationEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentKendraConfigurationEl {
    #[doc = ""]
    pub kendra_index: PrimField<String>,
}
impl BuildLexv2modelsIntentKendraConfigurationEl {
    pub fn build(self) -> Lexv2modelsIntentKendraConfigurationEl {
        Lexv2modelsIntentKendraConfigurationEl {
            kendra_index: self.kendra_index,
            query_filter_string: core::default::Default::default(),
            query_filter_string_enabled: core::default::Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentKendraConfigurationElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentKendraConfigurationElRef {
    fn new(shared: StackShared, base: String) -> Lexv2modelsIntentKendraConfigurationElRef {
        Lexv2modelsIntentKendraConfigurationElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentKendraConfigurationElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `kendra_index` after provisioning.\n"]
    pub fn kendra_index(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.kendra_index", self.base))
    }
    #[doc = "Get a reference to the value of field `query_filter_string` after provisioning.\n"]
    pub fn query_filter_string(&self) -> PrimExpr<String> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.query_filter_string", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `query_filter_string_enabled` after provisioning.\n"]
    pub fn query_filter_string_enabled(&self) -> PrimExpr<bool> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.query_filter_string_enabled", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentOutputContextEl {
    name: PrimField<String>,
    time_to_live_in_seconds: PrimField<f64>,
    turns_to_live: PrimField<f64>,
}
impl Lexv2modelsIntentOutputContextEl {}
impl ToListMappable for Lexv2modelsIntentOutputContextEl {
    type O = BlockAssignable<Lexv2modelsIntentOutputContextEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentOutputContextEl {
    #[doc = ""]
    pub name: PrimField<String>,
    #[doc = ""]
    pub time_to_live_in_seconds: PrimField<f64>,
    #[doc = ""]
    pub turns_to_live: PrimField<f64>,
}
impl BuildLexv2modelsIntentOutputContextEl {
    pub fn build(self) -> Lexv2modelsIntentOutputContextEl {
        Lexv2modelsIntentOutputContextEl {
            name: self.name,
            time_to_live_in_seconds: self.time_to_live_in_seconds,
            turns_to_live: self.turns_to_live,
        }
    }
}
pub struct Lexv2modelsIntentOutputContextElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentOutputContextElRef {
    fn new(shared: StackShared, base: String) -> Lexv2modelsIntentOutputContextElRef {
        Lexv2modelsIntentOutputContextElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentOutputContextElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `name` after provisioning.\n"]
    pub fn name(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.name", self.base))
    }
    #[doc = "Get a reference to the value of field `time_to_live_in_seconds` after provisioning.\n"]
    pub fn time_to_live_in_seconds(&self) -> PrimExpr<f64> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.time_to_live_in_seconds", self.base),
        )
    }
    #[doc = "Get a reference to the value of field `turns_to_live` after provisioning.\n"]
    pub fn turns_to_live(&self) -> PrimExpr<f64> {
        PrimExpr::new(
            self.shared().clone(),
            format!("{}.turns_to_live", self.base),
        )
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentSampleUtteranceEl {
    utterance: PrimField<String>,
}
impl Lexv2modelsIntentSampleUtteranceEl {}
impl ToListMappable for Lexv2modelsIntentSampleUtteranceEl {
    type O = BlockAssignable<Lexv2modelsIntentSampleUtteranceEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentSampleUtteranceEl {
    #[doc = ""]
    pub utterance: PrimField<String>,
}
impl BuildLexv2modelsIntentSampleUtteranceEl {
    pub fn build(self) -> Lexv2modelsIntentSampleUtteranceEl {
        Lexv2modelsIntentSampleUtteranceEl {
            utterance: self.utterance,
        }
    }
}
pub struct Lexv2modelsIntentSampleUtteranceElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentSampleUtteranceElRef {
    fn new(shared: StackShared, base: String) -> Lexv2modelsIntentSampleUtteranceElRef {
        Lexv2modelsIntentSampleUtteranceElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentSampleUtteranceElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `utterance` after provisioning.\n"]
    pub fn utterance(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.utterance", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentSlotPriorityEl {
    priority: PrimField<f64>,
    slot_id: PrimField<String>,
}
impl Lexv2modelsIntentSlotPriorityEl {}
impl ToListMappable for Lexv2modelsIntentSlotPriorityEl {
    type O = BlockAssignable<Lexv2modelsIntentSlotPriorityEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentSlotPriorityEl {
    #[doc = ""]
    pub priority: PrimField<f64>,
    #[doc = ""]
    pub slot_id: PrimField<String>,
}
impl BuildLexv2modelsIntentSlotPriorityEl {
    pub fn build(self) -> Lexv2modelsIntentSlotPriorityEl {
        Lexv2modelsIntentSlotPriorityEl {
            priority: self.priority,
            slot_id: self.slot_id,
        }
    }
}
pub struct Lexv2modelsIntentSlotPriorityElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentSlotPriorityElRef {
    fn new(shared: StackShared, base: String) -> Lexv2modelsIntentSlotPriorityElRef {
        Lexv2modelsIntentSlotPriorityElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentSlotPriorityElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `priority` after provisioning.\n"]
    pub fn priority(&self) -> PrimExpr<f64> {
        PrimExpr::new(self.shared().clone(), format!("{}.priority", self.base))
    }
    #[doc = "Get a reference to the value of field `slot_id` after provisioning.\n"]
    pub fn slot_id(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.slot_id", self.base))
    }
}
#[derive(Serialize)]
pub struct Lexv2modelsIntentTimeoutsEl {
    #[serde(skip_serializing_if = "Option::is_none")]
    create: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    delete: Option<PrimField<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    update: Option<PrimField<String>>,
}
impl Lexv2modelsIntentTimeoutsEl {
    #[doc = "Set the field `create`.\nA string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours)."]
    pub fn set_create(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.create = Some(v.into());
        self
    }
    #[doc = "Set the field `delete`.\nA string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs."]
    pub fn set_delete(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.delete = Some(v.into());
        self
    }
    #[doc = "Set the field `update`.\nA string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours)."]
    pub fn set_update(mut self, v: impl Into<PrimField<String>>) -> Self {
        self.update = Some(v.into());
        self
    }
}
impl ToListMappable for Lexv2modelsIntentTimeoutsEl {
    type O = BlockAssignable<Lexv2modelsIntentTimeoutsEl>;
    fn do_map(self, base: String) -> Self::O {
        BlockAssignable::Dynamic(DynamicBlock {
            for_each: format!("${{{}}}", base),
            iterator: "each".into(),
            content: self,
        })
    }
}
pub struct BuildLexv2modelsIntentTimeoutsEl {}
impl BuildLexv2modelsIntentTimeoutsEl {
    pub fn build(self) -> Lexv2modelsIntentTimeoutsEl {
        Lexv2modelsIntentTimeoutsEl {
            create: core::default::Default::default(),
            delete: core::default::Default::default(),
            update: core::default::Default::default(),
        }
    }
}
pub struct Lexv2modelsIntentTimeoutsElRef {
    shared: StackShared,
    base: String,
}
impl Ref for Lexv2modelsIntentTimeoutsElRef {
    fn new(shared: StackShared, base: String) -> Lexv2modelsIntentTimeoutsElRef {
        Lexv2modelsIntentTimeoutsElRef {
            shared: shared,
            base: base.to_string(),
        }
    }
}
impl Lexv2modelsIntentTimeoutsElRef {
    fn shared(&self) -> &StackShared {
        &self.shared
    }
    #[doc = "Get a reference to the value of field `create` after provisioning.\nA string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours)."]
    pub fn create(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.create", self.base))
    }
    #[doc = "Get a reference to the value of field `delete` after provisioning.\nA string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs."]
    pub fn delete(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.delete", self.base))
    }
    #[doc = "Get a reference to the value of field `update` after provisioning.\nA string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours)."]
    pub fn update(&self) -> PrimExpr<String> {
        PrimExpr::new(self.shared().clone(), format!("{}.update", self.base))
    }
}
#[derive(Serialize, Default)]
struct Lexv2modelsIntentDynamic {
    closing_setting: Option<DynamicBlock<Lexv2modelsIntentClosingSettingEl>>,
    confirmation_setting: Option<DynamicBlock<Lexv2modelsIntentConfirmationSettingEl>>,
    dialog_code_hook: Option<DynamicBlock<Lexv2modelsIntentDialogCodeHookEl>>,
    fulfillment_code_hook: Option<DynamicBlock<Lexv2modelsIntentFulfillmentCodeHookEl>>,
    initial_response_setting: Option<DynamicBlock<Lexv2modelsIntentInitialResponseSettingEl>>,
    input_context: Option<DynamicBlock<Lexv2modelsIntentInputContextEl>>,
    kendra_configuration: Option<DynamicBlock<Lexv2modelsIntentKendraConfigurationEl>>,
    output_context: Option<DynamicBlock<Lexv2modelsIntentOutputContextEl>>,
    sample_utterance: Option<DynamicBlock<Lexv2modelsIntentSampleUtteranceEl>>,
    slot_priority: Option<DynamicBlock<Lexv2modelsIntentSlotPriorityEl>>,
}
